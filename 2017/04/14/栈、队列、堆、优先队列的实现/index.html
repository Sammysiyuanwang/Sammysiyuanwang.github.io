<!DOCTYPE html>
<html lang="">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="栈、队列、堆、优先队列的实现"/>




  <meta name="keywords" content="Algorithm," />




  <link rel="alternate" href="/default" title="Prestige">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://yoursite.com/2017/04/14/栈、队列、堆、优先队列的实现/"/>


<meta name="description" content="Stack使用链表实现
要实现的功能：

pop() 链表头部删除
push() 链表头部插入
size() 压入元素时N+1，删除元素时N-1
isEmpty() 检查N是否为0

12345678910111213141516171819202122232425262728293031323334//链表实现栈public class Stack&amp;lt;Item&amp;gt; &amp;#123;	priv">
<meta property="og:type" content="article">
<meta property="og:title" content="栈、队列、堆、优先队列的实现">
<meta property="og:url" content="http://yoursite.com/2017/04/14/栈、队列、堆、优先队列的实现/index.html">
<meta property="og:site_name" content="Prestige">
<meta property="og:description" content="Stack使用链表实现
要实现的功能：

pop() 链表头部删除
push() 链表头部插入
size() 压入元素时N+1，删除元素时N-1
isEmpty() 检查N是否为0

12345678910111213141516171819202122232425262728293031323334//链表实现栈public class Stack&amp;lt;Item&amp;gt; &amp;#123;	priv">
<meta property="og:updated_time" content="2017-04-14T01:09:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="栈、队列、堆、优先队列的实现">
<meta name="twitter:description" content="Stack使用链表实现
要实现的功能：

pop() 链表头部删除
push() 链表头部插入
size() 压入元素时N+1，删除元素时N-1
isEmpty() 检查N是否为0

12345678910111213141516171819202122232425262728293031323334//链表实现栈public class Stack&amp;lt;Item&amp;gt; &amp;#123;	priv">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8466adbc25665cf7ee1a15e4fcb73643";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-74273646-1', 'auto');
        ga('send', 'pageview');
  </script>



    <title> 栈、队列、堆、优先队列的实现 · Prestige </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Prestige</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="https://github.com/ahonn">
        <li class="mobile-menu-item">
          
          
            Github
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Prestige</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://github.com/ahonn">
            
            
              Github
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          栈、队列、堆、优先队列的实现
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 14, 2017
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stack"><span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heap"><span class="toc-text">heap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue"><span class="toc-text">priority queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-text">堆排序</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><strong>使用链表实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>pop() 链表头部删除</li>
<li>push() 链表头部插入</li>
<li>size() 压入元素时N+1，删除元素时N-1</li>
<li>isEmpty() 检查N是否为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链表实现栈</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node first; <span class="comment">// 栈顶元素</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">//栈的大小</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">		Item item;   <span class="comment">//存储的值</span></div><div class="line">		Node next;   <span class="comment">//下一个节点</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> first == <span class="keyword">null</span>;  <span class="comment">// 或者 N == 0;</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item head)</span> </span>&#123;</div><div class="line">		Node oldfirst = first;</div><div class="line">		first = <span class="keyword">new</span> Node();</div><div class="line">		first.item = head;</div><div class="line">		first.next = oldfirst;</div><div class="line">		N++;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		Item item = first.item;</div><div class="line">		first = first.next;</div><div class="line">		N--;</div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><strong>链表实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>poll()</li>
<li>offer()</li>
<li>size()</li>
<li>isEmpty()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表实现队列</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node first; <span class="comment">// 队列头的元素</span></div><div class="line">	<span class="keyword">private</span> Node last; <span class="comment">// 队列尾的元素</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">// 队列长度</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node &#123;</div><div class="line">		Item item;</div><div class="line">		Node next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (N == <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</div><div class="line">		New oldlast = last;</div><div class="line">		last = <span class="keyword">new</span> Node();</div><div class="line">		last.item = item;</div><div class="line">		last.next = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">// 需要判断是否为空，是的话把first和last都要指向新节点</span></div><div class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</div><div class="line">			first = last;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			oldlast.next = last;</div><div class="line">		&#125;</div><div class="line">		N++;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">		Node item = first.item;</div><div class="line">		first = first.next;</div><div class="line">		<span class="comment">// 判空</span></div><div class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</div><div class="line">			last = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		N--;</div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p><strong>使用数组实现二叉堆（不使用数组的第一个位置）</strong></p>
<p>为什么用数组实现而不用链表：</p>
<ol>
<li>在插入操作中，链式实现需要一个getInsertNode方法去找插入在哪个结点之下，而在数组中，插入结点的位置下标是依次递增的（完全二叉树），插入操作的向上调整也可以直接根据下标来找父节点（思维和链式一样）</li>
<li>在删除堆顶的操作中，链式实现把lastNode的值赋给堆顶后，还要去找倒数第二个结点来更新lastNode，而在数组里就不需要，直接根据下标就知道哪个是倒数第二个结点，而且也不需要记录lastNode。</li>
</ol>
<p>删除操作的自上往下调整，左右子节点也可以通过下标来定，这个思路和链式一样，也是用递归，只是改为了下标来移动</p>
<p>需要实现的功能：</p>
<ul>
<li>less() 比较</li>
<li>swap() 交换</li>
<li>swim() 上浮</li>
<li>sink() 下沉</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority queue"></a>priority queue</h3><p><strong>利用堆实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>insert() 插入元素</li>
<li>max（） 返回最大元素</li>
<li>delMax() 删除最大元素</li>
<li>isEmpty()</li>
<li>size()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现priority Queue</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</div><div class="line">	<span class="comment">// 使用一个N+1的数组表示大小为N的堆，第一个位置pq[0]始终为空</span></div><div class="line">	<span class="comment">// 这样对于节点K，它的父节点的索引就是k/2，它的子节点就是2k和2k+1</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Key[] pq;  <span class="comment">//基于堆的完全二叉树，数组实现</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N;    <span class="comment">// 堆的大小</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</div><div class="line">		pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (N == <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span> </span>&#123;</div><div class="line">		pq[N++] = v;</div><div class="line">		swim(v); <span class="comment">// 底部(数组末尾)插入v，将v上浮到合适的位置</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//删除最大元素的时候，将数组顶端元素删除并把末尾的放到顶端，减小堆的大小</span></div><div class="line">	<span class="comment">//然后让这个元素下沉到合适位置</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</div><div class="line">		Key max = pq[<span class="number">1</span>];  <span class="comment">//从根节点得到最大元素</span></div><div class="line">		swap(<span class="number">1</span>, N--);    <span class="comment">// 将其和最后一个个节点交换，并刨除最后一个节点。</span></div><div class="line">		pq[N+<span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 防止对象游离</span></div><div class="line">		sink(<span class="number">1</span>);   <span class="comment">// 恢复堆的有序性</span></div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 辅助方法</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Key t = pq[i];</div><div class="line">		pq[i] = pq[j];</div><div class="line">		pq[j] = t;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</div><div class="line">			swap(k/<span class="number">2</span>, k);</div><div class="line">			k = k/<span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 下沉的时候要考虑下沉到两个节点中更大的那个节点</span></div><div class="line">	<span class="comment">// k的下个节点的下标是2k和2k+1</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt; N) &#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">			<span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</div><div class="line">			<span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;</div><div class="line">			swap(k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优先队列由一个基于堆的完全二叉树表示，存储于数组<code>pq[1..N]</code>中，<code>pq[0]</code>没有使用。在<code>insert()</code>中，我们将N加一并把新元素添加在数组最后，然后使用<code>swim()</code>恢复堆的秩序。在<code>delMax()</code>中，我们从<code>pq[1]</code>中得到最大的元素返回，然后把<code>pq[N]</code>移动到<code>pq[1]</code>，将N减一并用<code>sink()</code>恢复堆的秩序。同时还将不再使用的<code>pq[N+1]</code>设为null，以便系统回收它所占用的空间。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>首先，从右至左使用<code>sink()</code>函数构造子堆。开始只需要扫描数组一般的元素，因为可以跳过大小为1的子堆。最后我们在位置1上调用<code>sink()</code>方法，扫描结束。</p>
<p>我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头而非函数结束的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// heapsort</span></div><div class="line"><span class="comment">// 将swap()和less()的实现中的索引减一就可得到从a[0]到a[N-1]的排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> N = a.length;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</div><div class="line">		sink(a, k, N);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 构造好堆之后，把最大值换到最后，然后堆大小减一</span></div><div class="line">	<span class="comment">// 把换上来的新值sink下去，恢复堆。</span></div><div class="line">	<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">		swap(a, <span class="number">1</span>, N--);</div><div class="line">		sink(a, <span class="number">1</span>, N);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sink函数的另一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/// restores the heap property on a min-heap that has had the root element</div><div class="line">/// modified</div><div class="line">function reheap(heap) &#123;</div><div class="line">    var parent = 0, end = heap.length, child = 1;</div><div class="line">    // recurse down the minheap, swapping entries as needed to</div><div class="line">    // keep the heap property</div><div class="line">    while (child &lt; end) &#123;</div><div class="line">        // get the index of the smallest child node</div><div class="line">        var right = child + 1;</div><div class="line">        if ((right &lt; end) &amp;&amp; (heap[right] &lt; heap[child])) &#123;</div><div class="line">            child = right;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        // if the parent is less than both children, we&apos;re done here</div><div class="line">        if (heap[parent] &lt; heap[child]) break;</div><div class="line">           </div><div class="line">        // otherwise swap, and restore heap property on child node</div><div class="line">        var temp = heap[child];</div><div class="line">        heap[child] = heap[parent];</div><div class="line">        heap[parent] = temp;</div><div class="line"></div><div class="line">        parent = child;</div><div class="line">        child = 2 * parent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>附上另一种比较整合的实现，没有把swap和less函数分离出来的代码</p>
<p><a href="http://www.cnblogs.com/jingmoxukong/p/4303826.html" target="_blank" rel="external">堆排序实现</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <span>Sammy Wang</span>
    </p>
    <p class="copyright-item">
      <span>Origin: </span>
      <a href="http://yoursite.com">http://yoursite.com</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://yoursite.com/2017/04/14/栈、队列、堆、优先队列的实现/">http://yoursite.com/2017/04/14/栈、队列、堆、优先队列的实现/</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
  <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden />
    <label class="reward-button" for="reward">Reward</label>
    <div class="qr-code">
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/wechat.png" title="wechat">
        </label>
      
      
        <label class="qr-code-image" for="reward">
          <img class="image" src="/image/reward/alipay.png" title="alipay">
        </label>
      
    </div>
  </div>

    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Algorithm/">Algorithm</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2017/04/12/Linked-List/">
        <span class="next-text nav-default">Linked List</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ahonn95@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/ahonn/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Sammy Wang</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2017/04/14/栈、队列、堆、优先队列的实现/';
        this.page.identifier = '2017/04/14/栈、队列、堆、优先队列的实现/';
        this.page.title = '栈、队列、堆、优先队列的实现';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//ahonn.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  




    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
  </body>
</html>
