<!DOCTYPE html>
<html lang="">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/default" title="Prestige">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://yoursite.com/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Prestige">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Prestige">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Prestige">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />







<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: false,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8466adbc25665cf7ee1a15e4fcb73643";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-74273646-1', 'auto');
        ga('send', 'pageview');
  </script>



    <title> Prestige </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Prestige</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="https://github.com/ahonn">
        <li class="mobile-menu-item">
          
          
            Github
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Prestige</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://github.com/ahonn">
            
            
              Github
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/14/栈、队列、堆、优先队列的实现/">栈、队列、堆、优先队列的实现</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 14, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p><strong>使用链表实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>pop() 链表头部删除</li>
<li>push() 链表头部插入</li>
<li>size() 压入元素时N+1，删除元素时N-1</li>
<li>isEmpty() 检查N是否为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链表实现栈</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node first; <span class="comment">// 栈顶元素</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">//栈的大小</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">		Item item;   <span class="comment">//存储的值</span></div><div class="line">		Node next;   <span class="comment">//下一个节点</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> first == <span class="keyword">null</span>;  <span class="comment">// 或者 N == 0;</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Item head)</span> </span>&#123;</div><div class="line">		Node oldfirst = first;</div><div class="line">		first = <span class="keyword">new</span> Node();</div><div class="line">		first.item = head;</div><div class="line">		first.next = oldfirst;</div><div class="line">		N++;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Item <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">		Item item = first.item;</div><div class="line">		first = first.next;</div><div class="line">		N--;</div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><strong>链表实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>poll()</li>
<li>offer()</li>
<li>size()</li>
<li>isEmpty()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 链表实现队列</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node first; <span class="comment">// 队列头的元素</span></div><div class="line">	<span class="keyword">private</span> Node last; <span class="comment">// 队列尾的元素</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N; <span class="comment">// 队列长度</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> Node &#123;</div><div class="line">		Item item;</div><div class="line">		Node next;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (N == <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Item item)</span> </span>&#123;</div><div class="line">		New oldlast = last;</div><div class="line">		last = <span class="keyword">new</span> Node();</div><div class="line">		last.item = item;</div><div class="line">		last.next = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">// 需要判断是否为空，是的话把first和last都要指向新节点</span></div><div class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</div><div class="line">			first = last;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			oldlast.next = last;</div><div class="line">		&#125;</div><div class="line">		N++;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> Item <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">		Node item = first.item;</div><div class="line">		first = first.next;</div><div class="line">		<span class="comment">// 判空</span></div><div class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</div><div class="line">			last = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		N--;</div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p><strong>使用数组实现二叉堆（不使用数组的第一个位置）</strong></p>
<p>为什么用数组实现而不用链表：</p>
<ol>
<li>在插入操作中，链式实现需要一个getInsertNode方法去找插入在哪个结点之下，而在数组中，插入结点的位置下标是依次递增的（完全二叉树），插入操作的向上调整也可以直接根据下标来找父节点（思维和链式一样）</li>
<li>在删除堆顶的操作中，链式实现把lastNode的值赋给堆顶后，还要去找倒数第二个结点来更新lastNode，而在数组里就不需要，直接根据下标就知道哪个是倒数第二个结点，而且也不需要记录lastNode。</li>
</ol>
<p>删除操作的自上往下调整，左右子节点也可以通过下标来定，这个思路和链式一样，也是用递归，只是改为了下标来移动</p>
<p>需要实现的功能：</p>
<ul>
<li>less() 比较</li>
<li>swap() 交换</li>
<li>swim() 上浮</li>
<li>sink() 下沉</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority queue"></a>priority queue</h3><p><strong>利用堆实现</strong></p>
<p>要实现的功能：</p>
<ul>
<li>insert() 插入元素</li>
<li>max（） 返回最大元素</li>
<li>delMax() 删除最大元素</li>
<li>isEmpty()</li>
<li>size()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现priority Queue</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</div><div class="line">	<span class="comment">// 使用一个N+1的数组表示大小为N的堆，第一个位置pq[0]始终为空</span></div><div class="line">	<span class="comment">// 这样对于节点K，它的父节点的索引就是k/2，它的子节点就是2k和2k+1</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Key[] pq;  <span class="comment">//基于堆的完全二叉树，数组实现</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> N;    <span class="comment">// 堆的大小</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</div><div class="line">		pq = (Key[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (N == <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> N;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span> </span>&#123;</div><div class="line">		pq[N++] = v;</div><div class="line">		swim(v); <span class="comment">// 底部(数组末尾)插入v，将v上浮到合适的位置</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//删除最大元素的时候，将数组顶端元素删除并把末尾的放到顶端，减小堆的大小</span></div><div class="line">	<span class="comment">//然后让这个元素下沉到合适位置</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</div><div class="line">		Key max = pq[<span class="number">1</span>];  <span class="comment">//从根节点得到最大元素</span></div><div class="line">		swap(<span class="number">1</span>, N--);    <span class="comment">// 将其和最后一个个节点交换，并刨除最后一个节点。</span></div><div class="line">		pq[N+<span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 防止对象游离</span></div><div class="line">		sink(<span class="number">1</span>);   <span class="comment">// 恢复堆的有序性</span></div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 辅助方法</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">		Key t = pq[i];</div><div class="line">		pq[i] = pq[j];</div><div class="line">		pq[j] = t;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</div><div class="line">			swap(k/<span class="number">2</span>, k);</div><div class="line">			k = k/<span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 下沉的时候要考虑下沉到两个节点中更大的那个节点</span></div><div class="line">	<span class="comment">// k的下个节点的下标是2k和2k+1</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span> (<span class="number">2</span> * k &lt; N) &#123;</div><div class="line">			<span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">			<span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</div><div class="line">			<span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;</div><div class="line">			swap(k, j);</div><div class="line">			k = j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优先队列由一个基于堆的完全二叉树表示，存储于数组<code>pq[1..N]</code>中，<code>pq[0]</code>没有使用。在<code>insert()</code>中，我们将N加一并把新元素添加在数组最后，然后使用<code>swim()</code>恢复堆的秩序。在<code>delMax()</code>中，我们从<code>pq[1]</code>中得到最大的元素返回，然后把<code>pq[N]</code>移动到<code>pq[1]</code>，将N减一并用<code>sink()</code>恢复堆的秩序。同时还将不再使用的<code>pq[N+1]</code>设为null，以便系统回收它所占用的空间。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>首先，从右至左使用<code>sink()</code>函数构造子堆。开始只需要扫描数组一般的元素，因为可以跳过大小为1的子堆。最后我们在位置1上调用<code>sink()</code>方法，扫描结束。</p>
<p>我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头而非函数结束的末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// heapsort</span></div><div class="line"><span class="comment">// 将swap()和less()的实现中的索引减一就可得到从a[0]到a[N-1]的排序</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> N = a.length;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</div><div class="line">		sink(a, k, N);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 构造好堆之后，把最大值换到最后，然后堆大小减一</span></div><div class="line">	<span class="comment">// 把换上来的新值sink下去，恢复堆。</span></div><div class="line">	<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">		swap(a, <span class="number">1</span>, N--);</div><div class="line">		sink(a, <span class="number">1</span>, N);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sink函数的另一种实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/// restores the heap property on a min-heap that has had the root element</div><div class="line">/// modified</div><div class="line">function reheap(heap) &#123;</div><div class="line">    var parent = 0, end = heap.length, child = 1;</div><div class="line">    // recurse down the minheap, swapping entries as needed to</div><div class="line">    // keep the heap property</div><div class="line">    while (child &lt; end) &#123;</div><div class="line">        // get the index of the smallest child node</div><div class="line">        var right = child + 1;</div><div class="line">        if ((right &lt; end) &amp;&amp; (heap[right] &lt; heap[child])) &#123;</div><div class="line">            child = right;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        // if the parent is less than both children, we&apos;re done here</div><div class="line">        if (heap[parent] &lt; heap[child]) break;</div><div class="line">           </div><div class="line">        // otherwise swap, and restore heap property on child node</div><div class="line">        var temp = heap[child];</div><div class="line">        heap[child] = heap[parent];</div><div class="line">        heap[parent] = temp;</div><div class="line"></div><div class="line">        parent = child;</div><div class="line">        child = 2 * parent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>附上另一种比较整合的实现，没有把swap和less函数分离出来的代码</p>
<p><a href="http://www.cnblogs.com/jingmoxukong/p/4303826.html" target="_blank" rel="external">堆排序实现</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/12/Linked-List/">Linked List</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 12, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p><strong>当链表的结构发生变化时</strong>，就需要使用dummy node，dummy node的值不重要，主要作用在放在链表头部，返回链表头结点是可以直接返回dummy.next;</p>
<h2 id="修改链表顺序"><a href="#修改链表顺序" class="headerlink" title="修改链表顺序"></a>修改链表顺序</h2><h3 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h3><blockquote>
<p>最基本的链表翻转</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode next = head.next;</div><div class="line">            head.next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="92-Reverse-Linked-List-II"><a href="#92-Reverse-Linked-List-II" class="headerlink" title="92. Reverse Linked List II"></a>92. Reverse Linked List II</h3><blockquote>
<p>给定一个链表和m，n，翻转链表的第m个到第n个节点。</p>
<p>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, m = 2 and n = 4, return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
</blockquote>
<p>需要使用4个指针。<code>prem</code>保存m前一个节点，<code>mNode</code>是第m个节点（翻转前的第一个节点，翻转后的最后一个节点），<code>prev</code>和<code>head</code>用来翻转链表，翻转完成后，<code>prev</code>是之前n节点的位置（翻转后的第一个节点），<code>head</code>是n后面的节点的位置。因此调整顺序为<code>prem-&gt;prev-&gt;...-&gt;mNode-&gt;head</code>即可。</p>
<p>其中需要注意的一点就是for循环控制的时候，i=m开始，结束条件i&lt;n+1的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || m == n) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode prem, mNode;</div><div class="line">        dummy.next = head;</div><div class="line">        head = dummy;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        prem = head;</div><div class="line">        </div><div class="line">        head = head.next; <span class="comment">//第m个节点</span></div><div class="line">        mNode = head;</div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//翻转链表</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n + <span class="number">1</span>; i++) &#123;</div><div class="line">            ListNode next = head.next;</div><div class="line">            head.next = prev;</div><div class="line">            prev = head;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//跳出循环时候，prev是nNode的位置，head是n的下一个；</span></div><div class="line">        mNode.next = head;</div><div class="line">        prem.next = prev;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h3><blockquote>
<p>两两翻转链表，即 1-&gt;2-&gt;3-&gt;4 变为 2-&gt;1-&gt;3-&gt;4</p>
</blockquote>
<p><strong>该题最初想的时候陷入了使用<code>size</code>变量计数<code>%2</code>的方法里，后来看discuss发现使用快慢指针的方法可以不用计算就得到奇数项和偶数项，很牛~</strong></p>
<p>思路1：使用递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode n = head.next;</div><div class="line">        head.next = swapPairs(head.next.next);</div><div class="line">        n.next = head;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路2：使用快慢指针</p>
<p>新建dummy node, 然后从dummy开始，current记录当前节点，从dummy开始，first指针指向current的下一个节点，second指向下下个节点。current每次前行两步，因此first总是奇数个，second 总是偶数个。这样只需要把first和second交换就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode current = dummy;</div><div class="line">        <span class="keyword">while</span> (current.next != <span class="keyword">null</span> &amp;&amp; current.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode first = current.next;</div><div class="line">            ListNode second = current.next.next;</div><div class="line">            </div><div class="line">            first.next = second.next;</div><div class="line">            second.next = first;</div><div class="line">            current.next = second;</div><div class="line">            </div><div class="line">            current = current.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h3><blockquote>
<p>k组翻转链表，给定k，按k个为一组，组内翻转链表，不足k个的就不翻转</p>
<p>即：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>for k=2 return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code><br>for k=3 return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</blockquote>
<p>这个题其实是24题的升级版本，大思路为<strong>设置一个<code>current</code>指针，判断current后面的节点够不够k个，如果够，翻转k个，把<code>current</code>更新到翻转过部分的最后一个，再判断current后面够不够。。</strong></p>
<p>对于需要翻转的部分，使用for循环控制k个，需要4个指针，<code>current</code>指向要翻转部分的前一个节点，<code>start</code>保存翻转部分的头（翻转后的尾），<code>prev</code>和<code>node</code>是用来翻转的两个指针，初始<code>prev</code>指向current，<code>node</code>指向<code>start</code>，当翻转完成，<code>prev</code>是翻转部分翻转前的尾节点也就是翻转后的头节点，<code>node</code>是翻转部分的下一个节点。因此只要调整顺序为<code>current-&gt;prev-&gt;...-&gt;start-&gt;node</code>。该部分翻转完成。然后将current更新到<code>start</code>节点，从node开始下一部分翻转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode current = dummy;</div><div class="line">        ListNode start = <span class="keyword">null</span>;</div><div class="line">        ListNode prev = <span class="keyword">null</span>;</div><div class="line">        ListNode node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (hasK(current.next, k)) &#123;</div><div class="line">            prev = current;</div><div class="line">            start = current.next;</div><div class="line">            node = start;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">                ListNode next = node.next;</div><div class="line">                node.next = prev;</div><div class="line">                prev = node;</div><div class="line">                node = next;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//此时，start是翻转部分的尾节点，node是翻转部分后面的节点</span></div><div class="line">            <span class="comment">//current是翻转部分前面的节点，prev是翻转部分的头节点</span></div><div class="line">            start.next = node;</div><div class="line">            current.next = prev;</div><div class="line">            current = start;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasK</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            size++;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> size &gt;= k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h3><blockquote>
<p>在k除旋转链表，把后k个放到前面去</p>
<p>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and k = 2,<br>return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p>
</blockquote>
<p>该题dubug很久：犯了两个错误，一个是<strong>想当然认为k应当比链表长度小</strong>，其实有可能大，大的时候应当取余。二是在<strong>计算链表长度的时候</strong>，我用head指针遍历，遍历完成时候head已经不再是链表头部了，不能再当头部用，应当再赋值回头部才能用！</p>
<p>思路就是首先看k的值，用k%长度，若结果等于0或是链表长度，则不需要rotate，然后<code>slow</code>和<code>fast</code>指针从<code>dummy</code>开始走，<code>fast</code>先走k步，然后一起同步走，当<code>fast</code>到尾节点（不是null）时，<code>slow</code>到翻转节点的前一个。则<code>slow.next</code>为新头部，把<code>fast.next</code>接上<code>dummy.next</code>再把<code>slow</code>置空即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode fast = dummy;</div><div class="line">        ListNode slow = dummy;</div><div class="line">        <span class="comment">//因为k有可能大于长度，因此要计算下链表长度</span></div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            count++;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//一定记得，如果用head来算长度，算完已经变了null</span></div><div class="line">        <span class="comment">//要恢复成头结点，在这debug好久。。</span></div><div class="line">        head = dummy.next;</div><div class="line">        </div><div class="line">        k = k % count;</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k == count) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</div><div class="line">            fast = fast.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">            fast = fast.next;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        fast.next = dummy.next;</div><div class="line">        dummy.next = slow.next;</div><div class="line">        slow.next = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h2><blockquote>
<p>给定x，配分链表使得前面节点的值小于x，后面节点的值大于等于x，但是两部分不能改变原来的顺序</p>
<p>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and x = 3,<br>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
</blockquote>
<p>思路：维护两个链表，dummy和dummy2，原链表从dummy开始，遇到<code>&gt;=x</code>的节点就把它连到第二个链表，然后原链表中删除。最后把dummy和dummy2接起来就可以了。记得记录两个链表得头和尾以便接的时候用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        head = dummy;</div><div class="line">        ListNode p = dummy2;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (head.next.val &gt;= x) &#123;</div><div class="line">                ListNode temp = head.next;</div><div class="line">                p.next = temp;</div><div class="line">                p = p.next;</div><div class="line">                head.next = head.next.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = head.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        head.next = dummy2.next;</div><div class="line">        p.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h3><blockquote>
<p>修改链表顺序使得奇数个的节点的在前，偶数个节点在后，注意是节点第几个的奇偶而不是节点的值是奇偶。不能改变顺序和值。</p>
<p>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,<br>return <code>1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p>
</blockquote>
<p>思路，维护两个链表，奇数个的连在dummy1后面，偶数个的连在dummy2后面，然后dummy1连上dummy2。注意处理最后一个是奇数个的特殊情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode dummy2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        </div><div class="line">        ListNode current = dummy;</div><div class="line">        ListNode p1 = dummy1;</div><div class="line">        ListNode p2 = dummy2;</div><div class="line">        <span class="keyword">while</span> (current.next != <span class="keyword">null</span> &amp;&amp; current.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode odd = current.next;</div><div class="line">            ListNode even = current.next.next;</div><div class="line">            current = even;</div><div class="line">            p1.next = odd;</div><div class="line">            p1 = p1.next;</div><div class="line">            p2.next = even;</div><div class="line">            p2 = p2.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (current.next != <span class="keyword">null</span>) &#123;</div><div class="line">            p1.next = current.next;</div><div class="line">            p1 = p1.next;</div><div class="line">        &#125;</div><div class="line">        p1.next = dummy2.next;</div><div class="line">        <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</div><div class="line">            p2.next = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy1.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237. Delete Node in a Linked List"></a>237. Delete Node in a Linked List</h3><blockquote>
<p>只给你要删除的节点，不给头节点，让你删除节点</p>
</blockquote>
<p>只要把这个节点的值修改成后一个节点的值，把后一个节点删除即可。</p>
<p><strong>注意:</strong> 若给的节点是最后一个节点，此题无解。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        node.val = node.next.val;</div><div class="line">        node.next = node.next.next;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h3><blockquote>
<p>删除链表的倒数第n个节点</p>
</blockquote>
<p>两个指针，都从<code>dummy</code>开始走，<code>p1</code>先走n步，于是两个指针中间差n个节点。然后同步走，当<code>p1</code>走到<code>null</code>时，<code>p2</code>正好走到要删除的倒数第n个节点。因此，为了删除，让<code>p1.next</code>走到<code>null</code>时，<code>p2.next</code>是要删除的节点，删除即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode p1 = dummy, p2 = dummy;</div><div class="line">        dummy.next = head;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            p2 = p2.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(p2.next != <span class="keyword">null</span>) &#123;</div><div class="line">            p1 = p1.next;</div><div class="line">            p2 = p2.next;</div><div class="line">        &#125;</div><div class="line">        p1.next = p1.next.next;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a>203. Remove Linked List Elements</h3><blockquote>
<p>删除链表里值等于val的节点</p>
</blockquote>
<p>从dummy开始往后循环，如果<code>.next</code>值是要删除的，那么把它删除，但是head不往前走，因为有可能删掉之后下一个还是等于val的。只有<code>.next</code>的值不等于val时，指针往后走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        head = dummy;</div><div class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (head.next.val == val) &#123;</div><div class="line">                head.next = head.next.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = head.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="83-Remove-Duplicates-from-Sorted-List"><a href="#83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="83. Remove Duplicates from Sorted List"></a>83. Remove Duplicates from Sorted List</h3><blockquote>
<p>删除排序链表里的重复值节点，使得所有节点只出现一次</p>
<p>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
</blockquote>
<p>就从head节点开始（不需要从dummy节点，因为不可能需要删第一个节点），如果head.next跟head相同，删去head.next，不更新head，若不同，更新head。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (head.val == head.next.val) &#123;</div><div class="line">                head.next = head.next.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head = head.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h3><blockquote>
<p>删除重复节点，有重复值的节点一个都不保留</p>
<p>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>
</blockquote>
<p>思路：维护两根指针，<code>p1</code>从<code>dummy</code>开始走，<code>p2</code>初始为<code>p1</code>的下一个，如果<code>p2</code>和<code>p2.next</code>相等，<code>p2</code>向下走直到<code>p2 != p2.next</code>（这样解决原因主要是考虑到第一个节点就是重复的要删除的情况）时，<code>p1.next = p2.next</code>（这样把所有等于<code>p2</code>的都删了）；如果<code>p2</code>和<code>p2.next</code>不同，<code>p1</code>往下走即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        &#125;</div><div class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode p1 = dummy;</div><div class="line">        <span class="keyword">while</span> (p1.next != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode p2 = p1.next;</div><div class="line">            <span class="keyword">if</span> (p2.next != <span class="keyword">null</span> &amp;&amp; p2.val == p2.next.val) &#123;</div><div class="line">                <span class="keyword">while</span> (p2.next != <span class="keyword">null</span> &amp;&amp; p2.val == p2.next.val) &#123;</div><div class="line">                    p2 = p2.next;</div><div class="line">                &#125;</div><div class="line">                p1.next = p2.next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                p1 = p1.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="各种变形链表问题"><a href="#各种变形链表问题" class="headerlink" title="各种变形链表问题"></a>各种变形链表问题</h2><h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h3><blockquote>
<p>判断链表有环问题</p>
</blockquote>
<p>快慢指针，相遇则有环</p>
<h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h3><blockquote>
<p>判断环的入口</p>
</blockquote>
<p>当快慢指针相遇时，<code>head</code>从头部走，<code>slow</code>从相遇点走，一次走一步，当<code>head</code>和<code>slow</code>相遇的点，即为环的入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head;</div><div class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">            <span class="keyword">if</span> (slow == fast) &#123;</div><div class="line">                <span class="keyword">while</span> (slow != head) &#123;</div><div class="line">                    slow = slow.next;</div><div class="line">                    head = head.next;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> head;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h3><blockquote>
<p>找两个链表的交点</p>
</blockquote>
<p>思路1：先算出两个链表的长度，作差，让长的链表指针先走差不，然后两个指针同步走，当<code>p1 == p2</code>时，即为交点</p>
<p>思路2：将链表的尾部接到其中一个链表的头部，变成了找链表环入口的问题。</p>
<h3 id="234-Palindrome-Linked-List"><a href="#234-Palindrome-Linked-List" class="headerlink" title="234. Palindrome Linked List"></a>234. Palindrome Linked List</h3><blockquote>
<p>判断一个链表是不是palindrome</p>
</blockquote>
<p>思路1：翻转链表，然后比对翻转后的和翻转前的一样否。（注意只需要比对前一半即可）</p>
<p>思路2：快满指针，慢指针走的时候入栈，快指针到达尾部，慢指针到中点，继续往下走，比对慢指针和栈中pop()出来的元素是否相同。<strong>需要注意的一点就是，若是奇数个，记得慢指针跳过中间节点再比对</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        </div><div class="line">        ListNode slow = head;</div><div class="line">        ListNode fast = head;</div><div class="line">        </div><div class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//这里是fast != null &amp;&amp; fast.next != null </span></div><div class="line">        <span class="comment">//而不是fast.next 和 fast.next.next</span></div><div class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">            stack.push(slow);</div><div class="line">            slow = slow.next;</div><div class="line">            fast = fast.next.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//奇数情况跳过中间</span></div><div class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</div><div class="line">            ListNode cur = stack.pop();</div><div class="line">            <span class="keyword">if</span> (slow.val != cur.val) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            slow = slow.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h3><blockquote>
<p>深拷贝一个带随机指针的链表</p>
</blockquote>
<p>思路1：</p>
<p>比较直观，直接利用<code>HashMap</code>，key存原先链表的节点，value存复制的链表节点，先复制节点，再复制<code>next</code>和<code>random</code>指针，最后return即可</p>
<p>思路2：</p>
<ol>
<li>先复制节点，在每个节点后面加入复制的节点，<code>1-&gt;2-&gt;3</code>变成<code>1-&gt;1&#39;-&gt;2-&gt;2&#39;-3-&gt;3&#39;</code></li>
<li>把复制的节点的<code>random</code>指针复制了（head.next是复制的节点，head.next.next是原链表的下一个节点）。这里有个要<strong>注意</strong>的地方：<code>random</code>有可能指向空，因此要if语句特殊处理下，不然会空指针异常。</li>
<li>把大链表拆开，拆成两个，一个原来的，一个复制的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        RandomListNode dummy = <span class="keyword">new</span> RandomListNode (<span class="number">0</span>);</div><div class="line">        dummy.next = head;</div><div class="line">        <span class="comment">//1.make copy of each node</span></div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">            RandomListNode next = head.next;</div><div class="line">            RandomListNode copy = <span class="keyword">new</span> RandomListNode(head.label);</div><div class="line">            head.next = copy;</div><div class="line">            copy.next = next;</div><div class="line">            head = next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//2.assign random pointers of copy nodes</span></div><div class="line">        head = dummy.next;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (head.random == <span class="keyword">null</span>) &#123;</div><div class="line">                head.next.random = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                head.next.random = head.random.next;</div><div class="line">            &#125;</div><div class="line">            head = head.next.next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3.split the linkedlist to original and copy</span></div><div class="line">        head = dummy.next;</div><div class="line">        RandomListNode copy = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</div><div class="line">        RandomListNode p = copy;</div><div class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.next != <span class="keyword">null</span>) &#123;</div><div class="line">            p.next = head.next;</div><div class="line">            head.next = head.next.next;</div><div class="line">            p = p.next;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        p.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span> copy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Insert-into-a-Cyclic-Sorted-List-LintCode"><a href="#Insert-into-a-Cyclic-Sorted-List-LintCode" class="headerlink" title="Insert into a Cyclic Sorted List(LintCode)"></a>Insert into a Cyclic Sorted List(LintCode)</h3><blockquote>
<p>在一个排序循环链表中插入一个节点</p>
</blockquote>
<p>思路：关键考虑边界情况，如果都没有的话，要把插入节点的next指向自己才行。然后考虑两种情况：1是插入的点是大于链表最小值，小于链表最大值的，那么找到合适位置插入即可；2是如果小于链表最小值或者大于链表最大值呢，就要找到链表最大值和最小值接起来的那个地方插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> node a list node in the list</div><div class="line">     * <span class="doctag">@param</span> x an integer</div><div class="line">     * <span class="doctag">@return</span> the inserted new list node</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insert</span><span class="params">(ListNode node, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// Write your code here</span></div><div class="line">        ListNode ins = <span class="keyword">new</span> ListNode(x);</div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</div><div class="line">            ins.next = ins;</div><div class="line">            <span class="keyword">return</span> ins;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (node.next == node) &#123;</div><div class="line">            node.next = ins;</div><div class="line">            ins.next = node;</div><div class="line">            <span class="keyword">return</span> ins;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ListNode p = node;</div><div class="line">        ListNode next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (p.next != node) &#123;</div><div class="line">            <span class="keyword">if</span> (x &gt;= p.val &amp;&amp; x &lt;= p.next.val) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span> ((p.next.val &lt; p.val) &amp;&amp; (x &lt; p.next.val || x &gt; p.val)) <span class="keyword">break</span>;</div><div class="line">            p = p.next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        ins.next = p.next;</div><div class="line">        p.next = ins;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ins;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/12/K-NN/">K-NN</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 12, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>实质：对特征空间的划分</li>
<li>输入：实例的特征向量</li>
<li>输出：实例的类别标签（可以多类）或者回归问题为数字</li>
<li>性质：监督学习方法，可分类可回归</li>
<li>特点：没有显式的训练过程，属于懒惰学习(lazy learning)，在训练阶段只是把样本保存起来，训练时间开销为0，待收到样本时再进行处理</li>
</ul>
<p>三个要素：</p>
<ul>
<li>K的值（K=1时成为最近邻法）</li>
<li>距离度量（欧式距离）</li>
<li>决策规则（分类任务：多数表决，回归任务：平均值）</li>
</ul>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>根据给定的距离度量，在训练集中找出离x最近的K个点，涵盖这K个点的邻域记做\(N_K(x)\)</li>
<li>在\(N_K(x)\)中根据决策规则（如多数表决），确定x的类别y</li>
</ol>
<h3 id="三要素之K的值"><a href="#三要素之K的值" class="headerlink" title="三要素之K的值"></a>三要素之K的值</h3><ul>
<li>当K=1时，变为最近邻法，即对于输入x，将训练集中与x最近的点的类作为x的类。</li>
<li>增加K的值，使模型变得简单，当K=N时，就变成了整体的多数表决。容易欠拟合。</li>
<li>减少K的值，使模型变得复杂，对近邻更加敏感，如果近邻点是噪声，容易判错，因此容易过拟合。</li>
<li>一般采取交叉验证法来确定K的值。</li>
</ul>
<h3 id="三要素之距离度量"><a href="#三要素之距离度量" class="headerlink" title="三要素之距离度量"></a>三要素之距离度量</h3><p>常用距离：($l$为第$l$个特征)</p>
<p>\[L_p=(x_i,y<em>i)=(\sum^n</em>{l=1}{|x^{(l)}_i-x^{(l)}_j|}^p)^{\frac{1}{p}}\]</p>
<p>当p=2时，为欧式距离：</p>
<p>\[L_2=(x_i,y<em>i)=(\sum^n</em>{l=1}{|x^{(l)}_i-x^{(l)}_j|}^2)^{\frac{1}{2}}\]</p>
<p>当p=1时，为曼哈顿距离：</p>
<p>\[L_1=(x_i,y<em>i)=\sum^n</em>{l=1}{|x^{(l)}_i-x^{(l)}_j|}\]</p>
<p>当p=$\infty$时，为各个坐标距离的最大值：</p>
<p>\[L_1=(x_i,y_i)=\max_l{|x^{(l)}_i-x^{(l)}_j|}\]</p>
<h3 id="K近邻法的实现"><a href="#K近邻法的实现" class="headerlink" title="K近邻法的实现"></a>K近邻法的实现</h3><p>当数据集比较小时，可以采用线性扫描。但是如果数据集很大，很浪费时间，可以使用kd树（kd tree）方法实现K近邻。kd树是一个二叉树，是对K维空间的划分。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/04/07/网易传媒技术部数据挖掘面试复盘/">网易传媒技术部数据挖掘面试复盘</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Apr 7, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>时间：2017.4.6，面试时间不到一个小时</li>
<li>地点：网易北京研发中心</li>
<li>岗位：传媒技术部，数据挖掘实习生</li>
<li>简历：机器学习简历</li>
<li>感觉：还好</li>
</ul>
<p>这次面试比较简短，以至于还没反应过来就面试结束了。然后面试官跟我说过了的话一星期会有人通知，我说是通知过来二面吗，他说不是，没有二面，应该就是直接hr给我打电话了。有点小意外。</p>
<p>约得两点的面试，结果面试官有事，2点20才开始的面试，大概3点左右就结束了。上来先自我介绍，然后问了华为的项目，讲了做项目的经过，然后给他讲了RBM还有DBN的知识。问了为什么DBN可以防止梯度迷散。然后就继续问了能不能推一下BP神经网络，给他推了简单的3个节点的BP神经网络。</p>
<p>然后说做一道算法题把，我说好，结果他说能不能写一个快排。我说用我自己喜欢的语言吗，他说你会C++吗，不会，于是让用java写的。</p>
<p>比较基础，也没啥的，很快就写完了。感觉只是为了考我会不会写程序，并不是考算法。</p>
<p>写完之后给他讲了讲，他说可以。以为他要再出一道，结果他说可以了，今天就先到这儿了，回去等通知吧。稍微有点惊讶，以为会问的更多一些，不过感觉还好吧。虽然短点，还不错。</p>
<p>就是这些。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/23/百度系统部机器学习面试复盘/">百度系统部机器学习面试复盘</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 23, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>时间：2017.3.23，面试时间约一个小时</li>
<li>地点：百度科技园2号楼</li>
<li>岗位：百度系统部机器学习岗，实习岗</li>
<li>简历：机器学习简历</li>
<li>感觉：2分吧，被虐的体无完肤</li>
</ul>
<h2 id="过程复盘"><a href="#过程复盘" class="headerlink" title="过程复盘"></a>过程复盘</h2><p>这次面试面了1个小时零10分钟左右吧，是最近面的很短的一次，却是问问题最多的一次，也是不会的东西最多的一次。彻底被问跪~而且是两个面试官，交叉问，也是醉了。怎么讲，问了很多比较底层比较原理的东西吧，用古人的话说，只知道<strong>然</strong>是不够的，还会问很多<strong>所以然</strong>。但是怎么说，觉得他们问的很多东西，也并不普遍，有点过于追求难度和怪异了，不知道什么感觉，先把不会的知识点记下来补充吧。</p>
<p>由于节奏快，就把能记起来的，被问倒的点记下来。</p>
<h4 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h4><p>刚上来，开始问项目，第一个项目，问了RBM的，CRBM和RBM不同的地方在哪里，为什么可以处理时域数据，CRBM和RNN在处理时域数据上的不同是什么。然后问了RBM的能量函数。后来问了<strong>玻尔兹曼分布</strong>，这个我是真没听过，可能是数学基础上的一些东西，然后问了一个叫“Ising Model”的东西，答曰不懂。(查了下，玻尔兹曼分布是纯物理模型，或是统计力学模型，Ising Model是也纯物理理论的模型，这玩意问我干嘛。。我又不是学物理的)</p>
<h4 id="RNN-与-LSTM"><a href="#RNN-与-LSTM" class="headerlink" title="RNN 与 LSTM"></a>RNN 与 LSTM</h4><p>然后问了LSTM，RNN就问了缺点是啥，答曰梯度迷散，我说我可以讲一下，他说不用，直接讲LSTM的cell结构吧，给他画了LSTM的cell结构，然后继续问给你一个节点的什么什么样例，让我推导一下<strong>更新公式</strong>，。。。不会</p>
<h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p>结束之后问了第二个项目，问起来LR，问的也是偏数学，我忘记怎么描述的，一个问题是为什么LR可以输出概率，在数学上的解释。我解释了半天好像也没说到点子上，然后就给他推公式，推出损失函数来，问这个损失函数在数学上叫什么，不会，说了几个也不对。。。</p>
<h4 id="RF"><a href="#RF" class="headerlink" title="RF"></a>RF</h4><p>然后问随机森林，问假设我给你N个特征，要构造100颗树的随机森林，说一下构造过程。这里说的也不好，确实对过程理解不深。后来就转向问bagging的方法，问是怎么采样的，然后问bagging和boosting 的区别是什么</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>问起Linux，问我shell编程掌握咋样，出了一道题是</p>
<blockquote>
<p>你写了一个python程序，你要运行它，发现端口被占用了，用什么命令找到这个端口</p>
<p>然后问了参加比赛一般数据怎么处理，答曰pandas，问有没有用Linux处理过，我说没有，问了awk，我说也不会</p>
</blockquote>
<h4 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h4><p>问sql掌握到什么程度，我说基本语句都会。他问如何分组过滤，我说<code>group by having</code>，然后问你知道执行顺序吗，比如一条语句<code>select * from table where ... group by ... having....</code>，这条语句的执行顺序知道吗，答曰不知道。然后问了索引熟悉吗，答曰不懂。。。</p>
<h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><p>然后问起SVM了解多少，我说知道基本原理。他让讲对偶然问题，讲不出来，然后问使用核函数是为了解决什么问题，瞎扯了一些。。（SVM这块确实挺弱的，因为确实现在日薄西山）</p>
<h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h3><ol>
<li>给一个40亿的字符串，里面没有相同的字符，内存600M，问如何找到等于target的这个字符串</li>
<li>实现一个优先队列</li>
<li>问平衡树、红黑树、二叉搜索树这些数据结构的出现是为了解决什么问题</li>
<li>写堆排序</li>
<li>写归并排序</li>
</ol>
<p>擦擦啊，就最后归并排序会写，前面全不会，都在瞎扯。怎么说，这次的数据结构与算法直接就略过了基础题和简单题，比如排序，上来就直接问堆排序也是无语，然后问了很多底层原理的问题，我真的不懂。注重底层原理与实现，其实考察的确实都是数据结构，对一些算法考察的还少一点。整体有难度吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>怎么说，这次面试确实有一些难度，简单基础大路边的上的问题直接就不问了，转而追求原理性、深层次的问题，尤其是RBM那两个统计力学纯物理概念我也是服，RBM上还是为数不多被问倒的时候（上一次是Gibbs采样）。数据结构与算法也是问的很底层，很原理，觉得计算机专业可能会好一些，对于我这种半路出家的，很难。再就是对于模型，这次两人给我的感觉就是当我答上问题来了，立马会有更难更深的问题，一直要把我问倒为止，哪怕使用很深很偏的问题，挺无语的。这次还是有很多问题要加强吧，总结如下：</p>
<ul>
<li>SVM原理，核函数，对偶问题</li>
<li>RF的实现过程</li>
<li>LR的数学基础与概率解释</li>
<li>LSTM的推导与更新，只知道cell结构是不够的</li>
<li>sql的命令执行顺序，还有索引</li>
<li>Linux全部，包括awk</li>
<li>平衡树、红黑树、二叉搜索树为了解决什么问题</li>
<li>一些高级数据结构的实现（如优先队列）</li>
<li>堆排序</li>
</ul>
<p>诶。。。。。。。。。。好难。。。。。。加油吧~任重道远吶。。。。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/20/蓄水池抽样/">蓄水池抽样</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 20, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>转载自： <a href="http://blog.jobbole.com/42550/" target="_blank" rel="external">伯乐在线</a></p>
<p><strong>引言</strong>：众所周知，想要面试一个统计学家和软件工程师的合体——数据工程师——是件很难的事情。我在面试中常使用的方法是：提出即需要算法设计，又需要一些概率论知识的问题，来考察面试者的功底。下面就是在硅谷非常流行的例子：</p>
<blockquote>
<p>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</p>
</blockquote>
<p>当面对这样一个问题的时候，<strong>我们首先应该做的是：镇静</strong>。你的面试官并没有玩你，相反他可能特别想雇你。他可能正在为无尽的分析请求烦恼，他的ETL流水线已经不在工作，已有的机器学习模型也不再适合。他正想要你这样一个聪明人进来帮忙，他希望你答出来。</p>
<p><strong>第二件要做的事情是：不要在没有深入思考的情况下盲目作答。</strong>假设你的面试官读过Daniel Tunkelang的关于数据工程师的面试建议，那么这个面试题很可能就是他工作中实际遇到的问题。所以如果像下面一样随便回答，很可能会令你的面试官失望。</p>
<p>“我会首先将输入存到一个列表中，统计出数据流中数据的个数，在读取结束之后随机选取一个”（大哥， 你没看见题目已经说了，数据流长度很大或者未知么，不怕你的内存装不下？）</p>
<p><strong>第三件要做的事情是：从小例子开始分析。</strong>大部分的人都更容易解决具体问题（而不是抽象问题），最开始你设计的小例子可能和最后的问题之间相去甚远，但是却能启发你对问题的理解，给你灵感。</p>
<h3 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h3><p>如前面所说，对这个问题我们首先从最简单的例子出发：数据流只有一个数据。我们接收数据，发现数据流结束了，直接返回该数据，该数据返回的概率为1。看来很简单，那么我们试试难一点的情况：假设数据流里有两个数据。</p>
<p>我们读到了第一个数据，这次我们不能直接返回该数据，因为数据流没有结束。我们继续读取第二个数据，发现数据流结束了。因此我们只要保证以相同的概率返回第一个或者第二个数据就可以满足题目要求。因此我们生成一个0到1的随机数R,如果R小于0.5我们就返回第一个数据，如果R大于0.5，返回第二个数据。</p>
<p>接着我们继续分析有三个数据的数据流的情况。为了方便，我们按顺序给流中的数据命名为1、2、3。我们陆续收到了数据1、2和前面的例子一样，我们只能保存一个数据，所以必须淘汰1和2中的一个。应该如何淘汰呢？不妨和上面例子一样，我们按照二分之一的概率淘汰一个，例如我们淘汰了2。继续读取流中的数据3，发现数据流结束了，我们知道在长度为3的数据流中，如果返回数据3的概率为1/3,那么才有可能保证选择的正确性。也就是说，目前我们手里有1,3两个数据，我们通过一次随机选择，以1/3的概率留下数据3，以2/3的概率留下数据1.那么数据1被最终留下的概率是多少呢？</p>
<ul>
<li>数据1被留下：（1/2）*(2/3) = 1/3</li>
<li>数据2被留下概率：（1/2）*(2/3) = 1/3</li>
<li>数据3被留下概率：1/3</li>
</ul>
<p>这个方法可以满足题目要求，所有数据被留下返回的概率一样！</p>
<p>因此，我们做一下推论：假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。以这种方法选择，所有数据流中数据被选择的概率一样。简短的证明：假设n-1时候成立，即前n-1个数据被返回的概率都是1/n-1,当前正在读取第n个数据，以1/n的概率返回它。那么前n-1个数据中数据被返回的概率为：(1/(n-1))*((n-1)/n)= 1/n，假设成立。</p>
<p>这就是所谓的蓄水池抽样算法。它在分析一些大数据集的时候非常有用。你可以在这里找到Greg写的关于蓄水池抽样的算法介绍。本文后面会介绍一下在Cloudera ML中使用的两种：分布式蓄水池抽样和加权分布式蓄水池抽样。</p>
<p>（注：Cloudera ML是基于hadoop的数据分析和挖掘开源项目）</p>
<h3 id="LeetCode-382-Linked-List-Random-Node"><a href="#LeetCode-382-Linked-List-Random-Node" class="headerlink" title="LeetCode 382 Linked List Random Node"></a>LeetCode 382 Linked List Random Node</h3><blockquote>
<p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.</p>
<p>Follow up:<br>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p>
</blockquote>
<p>蓄水池抽样：</p>
<p>当随机到的数为0时，返回蓄水池中的那个节点，概率为1/(n+1)</p>
<ol>
<li><p>当链表长度为1时，<code>random.randint(0, 0)</code>恒等于0，因此抽到第1个元素的概率为1</p>
</li>
<li><p>假设抽取前n个元素的概率相等，均为1/n</p>
</li>
<li><p>当抽取第n+1个元素时：<br>若<code>random.randint(0, n)</code>等于0，则返回值替换为第n+1个元素，其概率为1/(n+1)；<br>否则，抽取的依然是前n个元素，其概率为1/n * n/(n+1) = 1/(n+1)</p>
</li>
</ol>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, head)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        @param head The linked list's head.</div><div class="line">        Note that the head is guaranteed to be not null, so it contains at least one node.</div><div class="line">        :type head: ListNode</div><div class="line">        """</div><div class="line">        self.head = head;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Returns a random node's value.</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        head = self.head</div><div class="line">        n = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> head:</div><div class="line">            <span class="keyword">if</span> random.randint(<span class="number">0</span>, n) == <span class="number">0</span>:</div><div class="line">                res = head.val</div><div class="line">            head = head.next</div><div class="line">            n += <span class="number">1</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Your Solution object will be instantiated and called as such:</span></div><div class="line"><span class="comment"># obj = Solution(head)</span></div><div class="line"><span class="comment"># param_1 = obj.getRandom()</span></div></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/16/GBDT/">GBDT</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 16, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>本文总结自知乎专栏文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25705586" target="_blank" rel="external">Learn R | GBDT of Data Mining</a></p>
<h3 id="是啥"><a href="#是啥" class="headerlink" title="是啥"></a>是啥</h3><p>GBDT（Gradient Boosting Decision Tree）是一种基于迭代所构造的决策树算法。该算法<strong>生成多棵决策树，并将所有树的结果进行汇总来得出结果</strong>，将决策树和集成思想进行了有效的融合。</p>
<h3 id="三个重点"><a href="#三个重点" class="headerlink" title="三个重点"></a>三个重点</h3><ol>
<li>GBDT中的DT是回归树而不是决策树</li>
<li>GB–梯度提升</li>
<li>GBDT中的shrinkage–缩减</li>
</ol>
<h4 id="GBDT之回归树"><a href="#GBDT之回归树" class="headerlink" title="GBDT之回归树"></a>GBDT之回归树</h4><p>GBDT中用的决策树并不是分类决策树，而是回归决策树。GBDT累加所有树的结果作为最终结果。</p>
<p>作为对比，简要回顾下分类树的运行过程：以ID3为例，穷举每一个属性特征的信息增益值，每一次都选取使信息增益最大的特征进行分枝，直到分类完成或达到预设的终止条件，实现决策树的递归构建。</p>
<p>回归树的运行流程与分类树基本类似，但有以下两点不同之处：</p>
<ul>
<li>第一，回归树的每个节点得到的是一个预测值而非分类树式的样本计数，假设在某一棵树的某一节点使用了年龄进行分枝（并假设在该节点上人数&gt;1），那么这个预测值就是属于这个节点的所有人年龄的平均值。</li>
<li>第二，在分枝节点的选取上，回归树并没有选用最大熵值来作为划分标准，而是使用了最小化均方差，即\(\frac{\sum_{i=1}^{n}{} (x_i-\bar{x} )^2}{n}\) 。这很好理解，被预测出错的次数越多，错的越离谱，均方差就越大，通过最小化均方差也就能够找到最靠谱的分枝依据。</li>
</ul>
<blockquote>
<p>一般来讲，回归树的分枝不太可能实现每个叶子节点上的属性值都唯一，更多的是达到我们预设的终止条件即可（例如叶子个数上限），这样势必会存在多个属性取值，那么该节点处的预测值自然就为基于这些样本所得到的平均值了。</p>
</blockquote>
<h4 id="GBDT之梯度提升"><a href="#GBDT之梯度提升" class="headerlink" title="GBDT之梯度提升"></a>GBDT之梯度提升</h4><p><strong>梯度提升是一种理念而非算法，其基本思想是沿着梯度方向训练一系列弱分类器并以一定的权重组合起来，形成最终的强分类器。</strong></p>
<p>这一系列弱分类器的训练方式便是GBDT的核心所在：<strong>每一棵树学习的是之前所有树结论和的残差</strong></p>
<blockquote>
<p>“Boosting，迭代，即通过迭代多棵树来共同决策。这怎么实现呢？难道是每棵树独立训练一遍，比如A这个人，第一棵树认为是10岁，第二棵树认为是0岁，第三棵树认为是20岁，我们就取平均值10岁做最终结论？当然不是！且不说这是投票方法并不是GBDT，只要训练集不变，独立训练三次的三棵树必定完全相同，这样做完全没有意义。之前说过，GBDT是把所有树的结论累加起来做最终结论的，所以可以想到每棵树的结论并不是年龄本身，而是年龄的一个累加量。GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义。”</p>
</blockquote>
<p>关于梯度提升的算法推导，请看李航老师《统计学习方法》中8.3节，提升树。</p>
<h4 id="GBDT之shrinkage"><a href="#GBDT之shrinkage" class="headerlink" title="GBDT之shrinkage"></a>GBDT之shrinkage</h4><blockquote>
<p>Shrinkage是GBDT的第三个基本概念，中文含义为“缩减”。它的基本思想就是：每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。换句话说缩减思想不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，只有通过多学几棵树才能弥补不足。</p>
</blockquote>
<p>Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分（step*残差）逐步逼近目标，step一般都比较小，如0.01~0.001（注意该step非gradient的step），导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://blog.csdn.net/w28971023/article/details/8240756" target="_blank" rel="external">GBDT（MART） 迭代决策树入门教程 | 简介</a></p>
<p><a href="http://www.cnblogs.com/maybe2030/p/4734645.html" target="_blank" rel="external">决策树与迭代决策树（GBDT）</a></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/阿里巴巴阿里妈妈广告部门面试复盘/">阿里巴巴阿里妈妈广告部门面试复盘</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>时间：2017.3.7，面试时间约两个半小时（一面）</li>
<li>地点：望京阿里巴巴绿地中心</li>
<li>岗位：阿里妈妈广告算法岗，实习岗</li>
<li>简历：网申简历 + 机器学习简历</li>
<li>感觉：面完蛮开心的，4分？</li>
</ul>
<h2 id="过程复盘"><a href="#过程复盘" class="headerlink" title="过程复盘"></a>过程复盘</h2><p>其实是阿里巴巴暑期实习校招内推的面试，特别早，3月份就面了，整体感觉还不错，因为她问的知识点，问题上答得自己感觉还可以，算法想的有点坎坷，在提示下写出来的。还有就是对广告算法了解的实在不够多。</p>
<p>其实开头略尴尬，只收到了电话面试的通知，木有收到短信或者邮件，导致我来到望京绿地中心了都不知道给谁打电话，回电话是阿里巴巴北京的主机号，也是醉了，辗转到前台接上面试官的电话，才找到了人继续面试。尴尬的一笔。</p>
<p>面试官是个妹子，很亲和。上来就开始，都木有自我介绍就开始问。先问了问个人信息，还问了是不是保研的之类。然后问常用的模型是什么。然后就说到了LR，让我给写LR的损失函数，老生常谈，写公式，推公式，写概率、损失函数、梯度下降用来最优化，然后更新公式，还可以，没有卡壳。然后她问了梯度下降能不能达到全局最优解，答曰不能，容易陷入局部最优，相比之下需要使用随机梯度下降(SGD)，这里讲的不好，没讲清楚，不过她也很好的表示理解，问每次是对什么进行梯度下降，答曰对一个随机样本梯度下降，她说OK~就过了</p>
<p>然后问你研究神经网络应该知道batchdata，一般是怎么设定这个batchsize的。答曰按直觉。。尴尬。她说举个例子，就给她举了项目里调参数的例子，她表示懂了。过程中给她讲了RBM，DBN，同时也被问到了RNN，给她讲了RNN的原理。后来又问到了有没有使用过caffe或者tensorflow的经验呢巴拉巴拉，答曰只了解一点，没有用过，实验室没条件。</p>
<p>然后就问到了BP算法。我说确实时间有点久了，我可以试着推一下。确实有点想不起来，表现的不是很好，不过大体意思能说明白。考前应该好好看一下的，当时花了那么多时间推BP，丢分简直不应该。然后她问了某一个节点的梯度跟哪些节点有关系，答曰上一层跟它有连接的节点。然后就过了</p>
<p>然后呢，就开始做题了。</p>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><blockquote>
<p>给你一个广告的一天的日志，里面是一条一条的query，让你统计这个日志里数量最多的前K个query，先不考虑数据量很大的问题。</p>
<p>然后follow up就是，如果数据量很大，内存如果无法一下都读取，怎么办？</p>
</blockquote>
<p>先跟我聊思路和复杂度，我说用一个hashmap，把每一个query的数量统计下来，O(n)的复杂度，key的值是query，value的值是query出现的数量，然后她问key就是存string吗，还是什么，我说现在想的就是这样。然后她问怎么取前K个，我说排序。她说能不能有小于O(nlogn)的方法。其实这里被绕进去了，很好想到的问题，跟她饶了好久，总是在排序上。其实开一个K的hashmap，然后遍历总得hashmap，如果当前的query的值大于K个的最小值，那么我就把这个替换过去，这样遍历完了就得到了前K个数量的query了</p>
<p>然后开始写代码，我说用python行吗，她说她不会，我心说那我更得用python了哈哈哈哈哈，然后我就深沉的说没事，我给你讲思路，她说行。然后就写，写完就讲。讲完OK，过……</p>
<p>然后，就follow up……问如果数据量特别大，大到那个日志内存都读不完，怎么办？</p>
<p>刚开始被问懵了，其实还是没见过这种题。她一直在引导我，可是我就是不开窍。其实就是分块，这个我倒是想到了。没想到的是，按query分块，然后分块统计，，每次取那个总得大dict来比较的时候只取出与query有关的key值不就可以了嘛。</p>
<h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><p>然后继续就是问了些特征工程的问题。</p>
<blockquote>
<p>说如果我们能给你很多用户的购买信息，让你设计模型评估用户的购买力，你会设计哪些特征？</p>
</blockquote>
<p>开放性的问题，回答还可以。设计年龄啊，性别啊，购买时间，在页面停留时间等等特征</p>
<blockquote>
<p>然后问了如果让你评估用户是否会去点广告，广告的转化率问题，你怎么设计特征？</p>
</blockquote>
<p>还是开放新问题，在上面问题上讨论了下，也没有对错反正，想不太起来了，大体就是那些</p>
<p>最后就是你有什么问题要问我没~</p>
<p>老生常谈，<strong>问了部门情况</strong>(就是广告的业务部门，看效果的)，<strong>能接触到什么</strong>（hadoop肯定可以，但是貌似不会接触到很多深度学习的东西，比如tensorflow, caffe什么的），<strong>常用的语言是什么</strong>（线上会是java，线下自己弄就无所谓了，也有写python的）。然后就是实习时间啦，转正啦之类的，没有很多有营养的东西，大概就是酱紫。</p>
<p>然后就是送我出来，等通知了。</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/面试复盘：网易-搜狗/">面试复盘：网易+搜狗</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h2 id="网易机器学习（深度学习）岗"><a href="#网易机器学习（深度学习）岗" class="headerlink" title="网易机器学习（深度学习）岗"></a>网易机器学习（深度学习）岗</h2><ul>
<li>时间：2017.3.2，面试时间约两个小时（一面）</li>
<li>地点：网易北京研发中心</li>
<li>岗位：网易传媒技术部，机器学习/深度学习 实习岗</li>
<li>简历：应聘深度学习岗位简历</li>
<li>感觉：还不错，4分</li>
</ul>
<p>首先就是自我介绍，不表，没营养。。</p>
<p>然后就开始做题。。。。</p>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>先写<strong>二分查找</strong>：<br>尴尬的是<code>start = mid</code>写反了，写成了<code>mid = start</code></p>
<p>第二题是<strong>二叉树两个节点的公共祖先</strong>，我说这个题没遇到过，可能不会，然后又改成<strong>求两个链表的交点</strong>，面试官说这两个题是一样的，会一个就都会了。</p>
<p>当时写了一个通过python列表，把各节点的值加入列表里从后面开始找的算法，是<strong>错误</strong>的，如果所有节点的值都是1，怎么办，算法没法运行了。</p>
<p>后来新的思路：</p>
<ol>
<li>首先正向考虑，交点之后的链表长度是相等的，区别在于交点之前的链表。因此先求两个链表的长度，求长度差。让长的链表的指针先走长度差个节点，然后两个指针一块往下走，当两个链表的节点相同时，即为交点。 </li>
<li>把一个链表的尾部跟另一个链表的头连起来，就变成了链表有环的问题，就变成了如何找入环的第一个节点的问题，但是当时<strong>这个找第一个节点的算法答得不好</strong></li>
</ol>
<p>然后做题完成，问了简历上的项目，比较详细的问了DBN与RBM，RBM的能量函数，条件概率公式，如何构成DBN；</p>
<p>问了上海联通大赛的一些问题，整个做题过程，用了哪些特征，哪些特征影响大</p>
<p>然后天池大赛的用了哪些特征，用过哪些模型</p>
<p>问除了DBN，深度学习还了解什么，我说了解一些RNN，给他简单讲了一下原理，然后是LSTM的简单原理</p>
<p>问CNN了解吗，讲了一些CNN的简单原理，问了CNN的优缺点</p>
<p>项目的MATLAB代码的一些简单交流，然后问python的theano接触过多少，问用theano和MATLAB的区别是什么(<strong>theano很多东西封装好了，可以直接使用，比如梯度下降、归一化啊之类的，MATLAB要完全自己写</strong>)</p>
<p>ps: python的封装性优于matlab也是刚刚问题中提到的一些，刚开始回答的这个，面试官说这是python的特点而不是theano的特点</p>
<p>还问在nlp方面有什么了解的吗？我说会一点定啊word2vector，面试官瞬间很感兴趣，结果我就懂一点皮毛，说了下就算了。然后他说这些知识不会没事儿，可以再学。</p>
<p>一面暂时就想到这些。当时面完1点了，然后有人过来带我去吃饭，说是吃完饭接着面，但是我两点有搜狗的面试，只得拒绝，再约时间二面。</p>
<h2 id="搜狗数据挖掘岗"><a href="#搜狗数据挖掘岗" class="headerlink" title="搜狗数据挖掘岗"></a>搜狗数据挖掘岗</h2><ul>
<li>时间：2017.3.2，面试时间约1个小时（一面）</li>
<li>地点：搜狐网络大厦</li>
<li>岗位：搜狗网页搜索部 数据挖掘实习岗</li>
<li>简历：应聘机器学习岗位简历</li>
<li>感觉：不好，2.5分吧</li>
</ul>
<p>总体感觉不理想，可能上午面了一上午，有点累，而且面试官刚开始语气特别冲，给人一种压迫感，但是面试结束之后语气缓和下来发现其实挺和蔼，还指出了我的不足，哪里需要加强：<strong>（leetcode刷题 + Linux）</strong></p>
<p>上来先自我介绍，然后就是问能不能保证实习6个月，每周保证几天，老师知不知道。巴拉巴拉，很强势，略吓人！！</p>
<p>先问了Linux，问掌握到什么程度，问了一个文件排序的问题，不会。。。。</p>
<p>还是问RBM与DBN的问题，跟上午差不多，说了能量函数和概率公式</p>
<p>问了RNN和LSTM，RNN讲的还可以，LSTM讲的太浅，好像不太受认可，过程中问了梯度迷散和梯度爆炸问题，<strong>梯度爆炸</strong>不会</p>
<p>项目上大同小异，怎么做的，流程是怎样，特征有哪些，用的什么模型</p>
<p><strong>机器学习方面</strong></p>
<p>首先问的是<strong>混淆矩阵</strong>，答曰不懂。然后进一步问如何判断结果的好坏，（ROC， AUC）这些，不懂，说应该要掌握一下这些。</p>
<p>然后让讲一下GBDT，说了一下原理，不满意，继续问深的，每一个树用的什么树（C30,C45还是CART），我说不太懂，基本都是找到代码来用，没有深入理解理论</p>
<p>问hadoop了解不，答曰不了解，实验室没条件。</p>
<h3 id="算法题："><a href="#算法题：" class="headerlink" title="算法题："></a>算法题：</h3><p><strong>给定一个数组A和A的长度n。求a, b 满足<code>0&lt;=a&lt;b&lt;=n</code>,使得<code>A[b] - A[a]</code>的差最大。</strong></p>
<p>其实就是广点通面试的第一题，当时回来没看，还是不会做。(本质上是动态鬼哭啊)</p>
<p>经过提示，把它的最小值和差存下来，用O(n)的方法可以做到。写完之后给面试官看，<strong>没有考虑边界条件</strong>，尴尬。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_difference</span><span class="params">(nums)</span>:</span></div><div class="line">	<span class="keyword">if</span> len(nums) == <span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">	min_value = nums[<span class="number">0</span>]</div><div class="line">	d = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">		<span class="keyword">if</span> nums[i] &lt; min_value:</div><div class="line">			min_value = nums[i]</div><div class="line">		<span class="keyword">elif</span> nums[i] - min_value &gt; d:</div><div class="line">			d = nums[i] - min_value</div><div class="line"></div><div class="line">	<span class="keyword">return</span> d</div></pre></td></tr></table></figure>
<p>###总结<br>能想起来的基本这些，表现不太好。后来他送我出来，很nice的给我讲了我的问题：语言会python会java可以，C++不会也没关系，够了。最好能有一点项目。DBN这一块掌握的可以了，LSTM掌握的不行，有点差。然后hadoop实验室没条件就算了，现在很容易接触到，是个公司就在用。<strong>主要两点，首先leetcode刷题，第二，把linux搞搞，这两点可以自己做。</strong></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2017/03/08/腾讯广点通数据挖掘岗实习生面试复盘/">腾讯广点通数据挖掘岗实习生面试复盘</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 8, 2017
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <ul>
<li>时间：2016.12.15，面试时间约一个半小时（两面）</li>
<li>地点：中关村银科大厦</li>
<li>岗位：广点通的数据挖掘实习岗</li>
<li>简历：V2版简历</li>
<li>感觉：还可以，给自己打3分吧(5分制)</li>
</ul>
<h2 id="过程复盘"><a href="#过程复盘" class="headerlink" title="过程复盘"></a>过程复盘</h2><p>今天也算是确定找工作方向之后的初次面试，收到通知后还是很认真准备了的，而且第一次面腾讯，内心未免有一些小激动。整体感觉还好吧，我感觉面的还算可以，比暑假傻了吧唧面百度贴吧时好多了，可能还是达不到面试官的要求吧，在二面面完挂掉。</p>
<p><strong>一面：</strong></p>
<p>面试官是个美女，比较温柔，上来先自我介绍，聊项目，聊自己在项目中都做了什么工作，印象最深刻的和最难的部分，给她详细讲了华为项目中的RBM算法，后来又跟她聊了两个比赛，比赛说了个大概，没有深入展开。然后说做道题，出了一道算法题：</p>
<p>给出一个列表是一天的股票成交价格，如<code>[1, 7, 4, 10, 9, 4, 2]</code>，求如果买卖股票能获得最大收入。一天只能买一次，卖一次，且必须先买入再卖出。</p>
<p><strong>其实根本上是一个求列表元素最大差的问题，只不过元素受限，一定是列表后面元素减前面元素的差。</strong></p>
<p>当时的解法：</p>
<ol>
<li>O(n2)时间复杂度，很容易想，两个for循环，i 从头一个元素开始，j 从 i 开始，求<code>lst[j] - lst[i]</code>的最大值. <strong>时间复杂度太高，被否定</strong></li>
<li>O(nlogn)时间复杂度，想法是递归，先分成前后两个列表<code>left, right</code>，求<code>max(right) - min(left)</code>，把这个值记下来，然后再分别对<code>left, right</code>进行分割求差，递归调用直到两个都是一个元素即可遍历 <strong>python代码没写出来，递归掌握不好</strong></li>
</ol>
<p>第二种方法当时给了20分钟，最后没写出代码，但把思想讲明白了，接下来就是二面</p>
<p><strong>二面：</strong></p>
<p>两次面试间隔大约5分钟吧，去了一趟洗手间，二面开始，是个做技术的小哥，穿着白袜子大拖鞋就过来面试了，<em>印象深刻</em>！</p>
<p>上来直入主题，看了简历，直接开始问比赛，问这个天池大赛是个什么情况，具体介绍了一下，然后问你们用的特征都是什么，我说一天的几个小时，一周的几天。然后问哪个特征的相关性最高，答曰一天内的时间相关性最高。然后问最后一共用了多少特征，我说就这两个，他<strong>一脸黑线</strong>。。。然后简单说了说上海联通数据大赛的情况，收获多少。他还详细问了这两个比赛投入了多少时间，答曰天池大概4到5天，然后上海联通因为自己做的投入10到15天左右吧。</p>
<p>然后开始做题：</p>
<p><strong>第一题</strong>是链表翻转，不限语言，于是用python写的，写完之后这哥们很傻比的揪住我的prev指针先置空后就不应该有next属性，非得让我改，<strong>我的方法明明leetcode都通过了的！！！！</strong></p>
<p><strong>第二题</strong>是写一个函数，传入一个数n,然后打印从1到n这些数的全排列，共有<code>n!</code>种排列。我的思想还是递归，分成两个列表<code>lst1,lst2</code>，<code>lst1</code>前n-1个元素，<code>lst2</code>最后1个元素，然后打印他们两个的全排列，两种方法，再递归调用<code>lst1</code>的，如此递归到<code>lst1</code>为两个元素即可。</p>
<p>函数实现上出了点问题，还是递归掌握有问题，函数打印上出了问题，我的递归调用比如调用到<code>lst1</code>时，打印<code>lst1</code>分裂后的排列方式，却忘记了<code>lst2</code>，最后改了半天也没改出来，就继续了，可能这块问题比较大把，思想有了，代码的实现上还是差一点</p>
<p>然后继续问<strong>进程</strong>和<strong>线程</strong>的区别是什么。答曰不知道，然后说因为是学通信的，因此计算机基础这块确实比较薄弱，这里应该也是挂掉的主要原因之一！</p>
<p>然后我引导他问一些机器学习的问题，他问我哪一块掌握的最好，我说LR吧，然后他说你讲讲LR吧，我开始讲，过程中他不断提问题，后来问到为什么用sigmoid函数而不用别的函数（分类问题上），我的答案不符合他的预期，他也没了耐心，就结束了面试</p>
<p>结束我问最后这个lr的问题答案是什么，他还不说。后来我问面的如何，他委婉的说不太适合，我问我哪一块还需要再提高，他说计算机基础上这些还是要学一学，知道一下的。</p>
<p>这次面试结束，整体情况如上。</p>
<p>补充：<br>一面时，那个女生还说了真正公司要做的可能比较杂，不想你们做竞赛可以专注于算法的提高，可能实习生需要做很多的杂活，不知道你能不能接受</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
      <a class="next" href="/page/2/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:ahonn95@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/ahonn/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
    
    
      
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Sammy Wang</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
  </body>
</html>
