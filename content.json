[{"title":"实现各种基本运算器","date":"2017-07-13T17:10:45.000Z","path":"2017/07/14/实现各种基本运算器/","text":"目录： 整数除法 平方根 乘方 大数加法（Add Two Strings） 大数乘法（Multiply Strings） 大数减法（Substract Two Strings） 边界处理问题上，要记得MIN_INT的abs要比MAX_INT大1的，因此往往需要单独处理 实现整数除法：leetcode 29. Divide Two Integers 不使用multiplication, division and mod operator实现整数除法。 解法：既然条件限制，就只能使用加减法和位运算，最容易想到的办法就是被除数一直减除数，直到为0为止，这样的时间复杂度O(n)。 有更好的方法： 首先考虑边界情况，divisor为0，dividend为0；dividend为MIN_INT且divisor为-1 考虑除数和被除数符号情况 使用位运算（左移一位是乘2，右移是除2）即，任何整数可以表示为以2为底的多项式的线性组合:$$a = b (a_n 2 ^ n + a_{n-1} 2 ^{n-1} + … + a_0 1)$$求此括号内的多项式就是求积因此做两点： 使用左移不断乘2找到第一个(2^shift) * b &gt; a，此时最高次应为shift - 1次 a 减去这个(2 ^ shift - 1) * b，result 记下这个数 重复1， 2，直到a &lt; b，此时为0 返回result，记得乘上符号。 123456789101112131415161718192021222324252627public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0) &#123; return Integer.MAX_VALUE; &#125; if (dividend == 0) &#123; return 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; int sign = ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) ? 1 : -1; long a = Math.abs((long)dividend); long b = Math.abs((long)divisor); int result = 0; while (a &gt;= b) &#123; int shift = 0; while (a &gt;= (b &lt;&lt; shift)) &#123; shift++; &#125; a -= b &lt;&lt; (shift - 1); result += 1 &lt;&lt; (shift - 1); &#125; return result * sign; &#125;&#125; 实现求平方根sqrt(x)leetcode 69. Sqrt(x) 实现int sqrt(x) 解法：二分法，找最后一个平方小于等于x的数。注意防止越界，要用mid &lt;= x / mid而不是mid * mid &lt;= x 1234567891011121314151617181920public class Solution &#123; public int mySqrt(int x) &#123; if (x &lt; 1) &#123; return 0; &#125; int start = 1; int end = x; while (start + 1 &lt; end) &#123; int mid = start + (end - start) / 2; if (mid &lt;= x / mid) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (end &lt;= x / end) return end; if (start &lt;= x / start) return start; return -1; &#125;&#125; 实现乘方pow(x, n)leetcode 50. Pow(x, n) 解法：基本思想是$x^n$可以分解为$x^{n/2} x^{n/2}$，因此用了一个二分思想可以降低时间复杂度达到O(logn)。但是这里面要*注意的点就是： 如果n是负数怎么办？ x的负次幂 = (1/x)的正次幂 如果n是奇数怎么办？ 是奇数，二分完要多乘一个x，因为余下一个 踩过的坑：递归调用时候，pow(x, n/2) pow(x, n/2)会超时，因此要用pow(x x, n/2)。。。 12345678910def myPow(self, x, n): if n == 0: return 1 if n &lt; 0: n = -n x = 1 / x if n % 2 == 0: return self.myPow(x * x, n/2) else: return x * self.myPow(x * x, n/2) 实现大数加法（字符串加法）415. Add Strings 实现两个整数的字符串加法。 解法：思路容易想，就是模拟手动加法，按位加就可以。但是坑还是有一些的。 处理好进位问题 处理好两个String长度不相等问题，因此要从后面开始加，所以从后向前遍历 处理好字符和ASCII码的问题，转为数字要charAt(i) - &#39;0&#39; 处理好最高位有进位，多个1的问题 不要弄成int[]去做，首先toCharArray()就只能变成char[]，其次int[]没有现成的函数直接变为String，toString()是对象方法，不是基本数据类型的方法！！！因此采用StringBuffer最后reverse一下 123456789101112131415161718public class Solution &#123; public String addStrings(String num1, String num2) &#123; int m = num1.length(); int n = num2.length(); StringBuffer res = new StringBuffer(); int carry = 0; for (int i = m - 1, j = n - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int x = i &gt;= 0 ? num1.charAt(i) - '0' : 0; int y = j &gt;= 0 ? num2.charAt(j) - '0' : 0; res.append((x + y + carry) % 10); carry = (x + y + carry) / 10; &#125; if (carry == 1) &#123; res.append(carry); &#125; return res.reverse().toString(); &#125;&#125; 实现大数乘法(Multiply String)43. Multiply Strings 实现两个String正整数的乘法操作 牛逼的算法：（详见leetcode最高赞答案） 两个数相乘，第i位置的数和第j位置的数的积会在最后求和的第i+j位和i+j+1位 num1[i] * num2[j] will be placed at indices [i + j, i + j + 1] 自己想的算法： 模拟手乘，每次num1乘以num2的一个字符(multiplyOne函数)，然后把所有结果求和(addString函数)，要记得num2字符如果是个位，结果*1，十位*10，做个循环。其次记得乘法和加法的最高位如果不是0的话，要记得加上最后的一位。 自己的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; public String multiply(String num1, String num2) &#123; if (num1.equals(\"0\") || num2.equals(\"0\")) &#123; return \"0\"; &#125; int m = num1.length(); int n = num2.length(); String postfix = \"\"; String ans = \"\"; for (int l = m - 1; l &gt;= 0; l--) &#123; String s = multiplyOne(num1.charAt(l), num2); ans = stringAdd(s + postfix, ans); System.out.println(s); System.out.println(ans); postfix += \"0\"; &#125; return ans; &#125; private String multiplyOne(char m, String num) &#123; if (m == '0') &#123; return \"0\"; &#125; StringBuffer sb = new StringBuffer(); int carry = 0; for (int i = num.length() - 1; i &gt;= 0; i--) &#123; int tmp1 = num.charAt(i) - '0'; int tmp2 = m - '0'; sb.append((tmp1 * tmp2 + carry) % 10); carry = ((tmp1 * tmp2 + carry) / 10); &#125; if (carry != 0) &#123; sb.append(carry); &#125; return sb.reverse().toString(); &#125; private String stringAdd(String num1, String num2) &#123; if (num1 == \"\" || num2 == \"\") &#123; return num1 == \"\" ? num2 : num1; &#125; int m = num1.length(); int n = num2.length(); int carry = 0; StringBuffer sb = new StringBuffer(); for (int i = m - 1, j = n - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int x = i &gt;= 0 ? num1.charAt(i) - '0' : 0; int y = j &gt;= 0 ? num2.charAt(j) - '0' : 0; sb.append((x + y + carry) % 10); carry = (x + y + carry) / 10; &#125; if (carry != 0) &#123; sb.append(carry); &#125; return sb.reverse().toString(); &#125;&#125;","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"Linux shell cmd","date":"2017-07-02T09:01:55.000Z","path":"2017/07/02/Linux-shell-cmd/","text":"总结一下linux shell中常用的命令： shell 基本命令拷贝命令：cp cp [option] source destination 移动命令：mv mv [option] source destination 可以用来将文件改名或者移动到别处 创建文件夹和删除空文件夹：mkdir , rmdir mkdir [option] dir-name rmdir [option] dir-name 必须是空文件夹 改变工作目录：cd列出目录：ls改变权限: su su [option] 使用者账号 显示进程命令：PS ps [option] kill 进程： kill kill [option] PID 搜索命令：grep grep 字符串 例：查看所有CMD里是java的进程： 使用BSD格式显示所有进程 ps -aux | grep java 使用标准格式显示所有进程 ps -ef | grep java 显示命令：echo echo 字符串 在显示器上显示一段文字 清楚屏幕信息：clearshell基本知识系统变量： $0: 该程序名字 $n: 该程序的第n个参数值 $*: 该程序所有参数 $#: 该程序参数的个数 $$: 该程序PID 从键盘输入变量值： read命令： read var1, var2, ..., varn 比较： -eq：相等 equal -ne：不等 not equal -gt: 大于 greater than -ge: 大于等于 greater equal -lt: 小于 less than -le: 小于等于 less equal 双引号及单引号：$echo &quot;$HOME $PATH&quot; – 显示变量值 /home/hbwork opt/kde/bin:/usr/local/bin: $echo &#39;$HOME $PATH&#39; – 显示单引号里的内容 $HOME $PATH if-else语句：1. if…else1234if [ expression ]then statement to be executed if expression is truefi 注意:expression和方括号之间必须有空格，分号是不同语句之间的分割符，如果一行只有一个语句，则不需加分号，见下例区别： 123456789101112131415!/bin/zshecho &quot;please print a&quot;read aecho &quot;please print b&quot;read bif [ $a -eq $b ];then echo &quot;a is equal to b&quot;fiif [ $a -ne $b ]then echo &quot;a is not equal to b&quot;fi 2. if…else…fi123456if [ expression ]then Statement(s) to be executed if expression is trueelse Statement(s) to be executed if expression is not truefi 3. if…elif…if123456789101112if [ expression 1 ]then Statement(s) to be executed if expression 1 is trueelif [ expression 2 ]then Statement(s) to be executed if expression 2 is trueelif [ expression 3 ]then Statement(s) to be executed if expression 3 is trueelse Statement(s) to be executed if no expression is truefi 4. 另外：test命令用于检查某个条件是否成立，与方括号类似 因此if…else语句可以写成一行以命令行的方式运行：if test $[2*3] -eq $[1+5]; then echo &#39;The two numbers are equal!&#39;; fi; 或者： 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;The two numbers are equal!&apos;else echo &apos;The two numbers are not equal!&apos;fi for loop1234567for 变量 in 列表do command1 command2 ... commandNdone 列表是你想遍历的一组值组成的序列，每个值通过空格分隔。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done while loop1234while commanddo Statement(s) to be executed if command is truedone 命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假 例：leetcode 195 tenth line: 输出文件的第10行 12345678cnt=0while read line &amp;&amp; [ $cnt -le 10 ]; do let &apos;cnt = cnt + 1&apos; if [ $cnt -eq 10 ]; then echo $line exit 0 fidone &lt; file.txt let 为做运算 最后&lt;为重定向，将file.txt传给while","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"Arrays & Two pointers","date":"2017-04-20T14:18:40.000Z","path":"2017/04/20/Arrays-Two-pointers/","text":"1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. 思路：用哈希表存储，key是值，value是索引，每次查找value-nums[i]是否在哈希表里，有的话取出索引跟i搭配即可。 1234567891011121314151617181920public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] output = new int[2]; if (nums == null || nums.length &lt; 2) &#123; return output; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int diff = target - nums[i]; if (map.containsKey(diff)) &#123; output[0] = map.get(diff); output[1] = i; break; &#125; else &#123; map.put(nums[i], i); &#125; &#125; return output; &#125;&#125; 167. Two Sum II - Input array is sorted 排序数组里找到和为target的两个值，返回这两个值的索引。 思路：两根指针的原始问题，一根指针从前往后，一根从后往前，如果两者相加大于target，那么说明和大了，因此后面指针减一，减小一点，如果两者相加小于target，那么说明和小了，前面指针加一，变大一点，直到找到。 123456789101112131415161718192021222324public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int[] output = new int[2]; if (numbers == null || numbers.length &lt; 2) &#123; return output; &#125; int left = 0; int right = numbers.length - 1; while (left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if (sum == target) &#123; output[0] = left + 1; output[1] = right + 1; break; //记得这里要break; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; left++; &#125; &#125; return output; &#125;&#125; Two Sum - Data structure design 设计一个数据结构，能add，向数据结构里添加元素；还能find(value)，找数据结构中是否存在两个数相加等于value，返回boolean。 思路1：利用Two Sum I的做法，利用哈希表。 思路2：利用Two Sum II的做法，排序，然后两根指针分别从两头找。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//思路1public class TwoSum &#123; private List&lt;Integer&gt; list = null; private Map&lt;Integer, Integer&gt; map = null; public TwoSum() &#123; list = new ArrayList&lt;Integer&gt;(); map = new HashMap&lt;Integer, Integer&gt;(); &#125; // Add the number to an internal data structure. public void add(int number) &#123; // Write your code here if (map.containsKey(number)) &#123; map.put(number, map.get(number) + 1); &#125; else &#123; map.put(number, 1); list.add(number); &#125; &#125; // Find if there exists any pair of numbers which sum is equal to the value. public boolean find(int value) &#123; // Write your code here for (int i = 0; i &lt; list.size(); i++) &#123; int num1 = list.get(i), num2 = value - num1; if ((num1 == num2 &amp;&amp; map.get(num1) &gt; 1) || (num1 != num2 &amp;&amp; map.containsKey(num2))) return true; &#125; return false; &#125;&#125;// Your TwoSum object will be instantiated and called as such:// TwoSum twoSum = new TwoSum();// twoSum.add(number);// twoSum.find(value);//思路2public class TwoSum &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // Add the number to an internal data structure. public void add(int number) &#123; // Write your code here list.add(number); &#125; // Find if there exists any pair of numbers which sum is equal to the value. public boolean find(int value) &#123; // Write your code here if (list.isEmpty() || list.size() &lt; 2) &#123; return false; &#125; Collections.sort(list, new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b) &#123; return a - b; &#125; &#125;); int left = 0; int right = list.size() - 1; while (left &lt; right) &#123; if (list.get(left) + list.get(right) &gt; value) &#123; right--; &#125; else if (list.get(left) + list.get(right) &lt; value) &#123; left++; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125; Remove Duplicate Numbers in Array(LintCode) 给一个数组，移除掉重复元素。不需要保持原来的顺序，并返回不重复元素的个数 思路1：利用hashMAP，记录元素出现次数，然后返回出现次数为1的即可 思路2：先排序，然后两根指针，len指针记录不重复的，i指针遍历，当i跟len不同时，len就+1并更新元素，这样把不重复的元素都放在前len个里了，又因为len从0开始，因此return len + 1个 123456789101112131415161718192021//思路1：注意map里Map.Entry的使用public class Solution &#123; /** * @param nums an array of integers * @return the number of unique integers */ public int deduplication(int[] nums) &#123; // Write your code here Map&lt;Integer, Boolean&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], true); &#125; int result = 0; for (Map.Entry&lt;Integer, Boolean&gt; entry : map.entrySet()) &#123; nums[result++] = entry.getKey(); &#125; return result; &#125;&#125;//思路2 Two Sum - Unique pairs(LintCode) 找到不同的和为target的pair的个数 思路：先排序，然后两根指针找的时候，如果相等，则left++, right--，完了判断下新的left是否跟之前相同，若相同，继续left++，知道跳过相同值即可。right同理。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; /** * @param nums an array of integer * @param target an integer * @return an integer */ public int twoSum6(int[] nums, int target) &#123; // Write your code here if (nums == null || nums.length &lt; 2) &#123; return 0; &#125; int count = 0; Arrays.sort(nums); int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; count++; left++; right--; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; right--; &#125; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; left++; &#125; &#125; else if (sum &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; return count; &#125;&#125; 15. 3Sum 3sum问题，找到所有不同的a+b+c = 0的a, b, c。 在2Sum问题上多加一层for循环，从i开始到nums.length-2结束。每次对(i+1, nums.lenth - 1)做2sum问题。记得要有两次删除重复的操作。 这题最初次做的时候，想法是for循环，然后把i换到第一个元素位置，再对(1, length - 1)做2sum问题，这样是不对的，明显有重复，变成了有放回的！！ 还有一个错误就是在里面判重时候要用while而不是if! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Solution &#123; /** * @param nums : Give an array numbers of n integer * @return : Find all unique triplets in the array which gives the sum of zero. */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); if (nums == null || nums.length &lt; 3) &#123; return results; &#125; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; // skip duplicate triples with the same first numebr if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1, right = nums.length - 1; int target = -nums[i]; twoSum(nums, left, right, target, results); &#125; return results; &#125; public void twoSum(int[] nums, int left, int right, int target, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; results) &#123; while (left &lt; right) &#123; if (nums[left] + nums[right] == target) &#123; ArrayList&lt;Integer&gt; triple = new ArrayList&lt;&gt;(); triple.add(-target); triple.add(nums[left]); triple.add(nums[right]); results.add(triple); left++; right--; // skip duplicate pairs with the same left // 这里用while而不是if! while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; left++; &#125; // skip duplicate pairs with the same right while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; right--; &#125; &#125; else if (nums[left] + nums[right] &lt; target) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125;&#125; 16. 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 注意：return的是和，而不是最小的差。 123456789101112131415161718192021222324252627public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (nums == null || nums.length &lt; 3) &#123; return 0; &#125; Arrays.sort(nums); int res = nums[0] + nums[1] + nums[nums.length - 1]; for (int i = 0; i &lt; nums.length - 2; i++) &#123; int left = i+1; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum &gt; target) &#123; right--; &#125; else &#123; left++; &#125; //这个判断在while循环里面，不是外面 if (Math.abs(target - sum) &lt; Math.abs(target - res)) &#123; res = sum; &#125; &#125; &#125; return res; &#125;&#125; 4.Median of Two Sorted Arrays 找两个有序数组的中位数 思路：写一个更牛逼的算法找两个有序数组的第K个数来解决这个问题。考虑找两个有序数组的第K个数，找这两个数组的第K/2个数，如果A[k/2-1] &lt; B[k/2-1]，那么第K个数一定不在A[k/2-1]里面，那么就可以把A的前k/2部分扔掉，递归找A的len - k/2和B两个数组中的第k - k/2个数（因为扔掉了k/2个数）；如果A[k/2-1]&gt;len(A)的话，那么第K个数一定不在B的前k/2中，所以扔掉B的前一部分。如此递归，递归出口为把A全部扔掉了，或者把B全部扔掉了，或者K==1时，返回两个数组第一个的最小值即可。 总结为：都不越界的话，谁的第k/2个值小，就扔掉谁的前一部分。谁的k/2越界了，就扔掉另一个的前一部分。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len = nums1.length + nums2.length; if (len % 2 == 1) &#123; return findKth(nums1, 0, nums2, 0, len/2 + 1); &#125; else &#123; return (findKth(nums1, 0, nums2, 0, len/2) + findKth(nums1, 0, nums2, 0, len/2 + 1)) / 2.0; &#125; &#125; private int findKth(int[] nums1, int start1, int[] nums2, int start2, int k) &#123; //终止条件 if (start1 &gt;= nums1.length) &#123; return nums2[start2 + k - 1]; &#125; if (start2 &gt;= nums2.length) &#123; return nums1[start1 + k - 1]; &#125; if (k == 1) &#123; return Math.min(nums1[start1], nums2[start2]); &#125; //这里设置的原因是如果k/2个数越界的问题 int mid1 = Integer.MAX_VALUE, mid2 = Integer.MAX_VALUE; if (start1 + k/2 - 1 &lt; nums1.length) mid1 = nums1[start1 + k/2 - 1]; if (start2 + k/2 - 1 &lt; nums2.length) mid2 = nums2[start2 + k/2 - 1]; if (mid1 &lt; mid2) &#123; return findKth(nums1, start1 + k/2, nums2, start2, k - k/2); &#125; else &#123; return findKth(nums1, start1, nums2, start2 + k/2, k - k/2); &#125; &#125;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"Dynamic Programming","date":"2017-04-20T14:17:35.000Z","path":"2017/04/20/Dynamic-Programming/","text":"70. Climbing Stairs 爬楼梯问题，一次能爬一级或者两级，问n阶台阶有几种走法 思路，关键点在于，n阶台阶的走法，是（n-1)级台阶的走法加上(n-2)级台阶的走法。因此可以使用递归。但是递归通常会溢出，那么使用动态规划思想，记录下每级台阶的走法。 12345678910111213141516171819202122232425262728293031323334//逆向走法public class Solution &#123; public int climbStairs(int n) &#123; // write your code here int[] map = new int[n+1]; Arrays.fill(map, Integer.MIN_VALUE); return helper(n, map); &#125; private int helper(int n, int[] map) &#123; if (n &lt; 0) return 0; if (n == 0) &#123; return 1; &#125; else if (map[n] &gt; -1) &#123; return map[n]; &#125; else &#123; map[n] = helper(n-1, map) + helper(n-2, map); &#125; return map[n]; &#125;&#125;//正向走法：public class Solution &#123; public int climbStairs(int n) &#123; if (n == 0) return 1; int[] f = new int[n+1]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; n + 1; i++) &#123; f[i] = f[i-1] + f[i-2]; &#125; return f[n]; &#125;&#125; 64. Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 思路，用一个二维矩阵记录到该点的最短路径，因为只能向右或想下走，因此递推公式为：D[m][n] = min(D[m-1][n], D[m][n-1]) + value[m][n].即左边和上边的min加上该点的值。 12345678910111213141516171819202122//该方法使用了extra space，也可以不使用直接在原矩阵上修改public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] D = new int[m][n]; D[0][0] = grid[0][0]; for (int j = 1; j &lt; n; j++) &#123; D[0][j] = D[0][j-1] + grid[0][j]; &#125; for (int i = 1; i &lt; m; i++) &#123; D[i][0] = D[i-1][0] + grid[i][0]; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; D[i][j] = Math.min(D[i-1][j], D[i][j-1]) + grid[i][j]; &#125; &#125; return D[m-1][n-1]; &#125;&#125; 62. Unique Paths 找从左上角走到右下角的不同的路径有多少条 思路：利用动态规划，每一个点的路径数等于左边点的路径数加上边点的路径数。其中最左边一列和最上边一行路径数都为1。递推公式为D[m][n] = D[m-1][n] + D[m][n-1]。开二维数组记录即可。 123456789101112131415public class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] D = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 || j== 0) &#123; D[i][j] = 1; &#125; else &#123; D[i][j] = D[i-1][j] + D[i][j-1]; &#125; &#125; &#125; return D[m-1][n-1]; &#125;&#125; 优化：上面的方法用了O(m*n)的space，可以优化到O(min(m, n))的space，考虑D[m][n]只有D[m-1][n]和D[m][n-1]有关，D[m][n-1]可以看成上一时刻的D[m][n]，因此用一维数组的空间即可。 123456789101112public class Solution &#123; public int uniquePaths(int m, int n) &#123; int[] res = new int[n]; res[0] = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; res[j] = res[j - 1] + res[j]; &#125; &#125; return res[n-1]; &#125;&#125; 63. Unique Paths II 在grid里有障碍导致不能通过 思路一样，就是遇到障碍的时候把该点的路径置0即可，但是需要注意一点是j不能从1开始遍历了，因为也有可能在j=0的时候有障碍，所以都需要遍历。 12345678910111213141516171819public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[] D = new int[n]; D[0] = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (obstacleGrid[i][j] == 1) &#123; D[j] = 0; &#125; else if (j &gt; 0) &#123; D[j] = D[j] + D[j-1]; &#125; &#125; &#125; return D[n-1]; &#125;&#125; 300. Longest Increasing Subsequence 找一个序列中的最长子序列，返回它的长度。 思路：O(n2)解法是，第n个数的最长子序列的长度应该为前面每一个比它小的数的最长子序列长度+1。这就是递推公式，外层大循环为第几个数，内层循环找n前面每一个比n小的数的最长子序列的长度，找到最长的+1。然后记得更新全局变量即可。 12345678910111213141516171819public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; if (nums == null) return 0; int longest = 0; int[] dp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; // 找到dp[0]到dp[i-1]中最大的升序序列长度且nums[j]&lt;nums[i] for (int j = 0; j &lt; i; j++) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = Math.max(dp[i], dp[j]); &#125; &#125; dp[i]++; longest = Math.max(longest, dp[i]); &#125; return longest; &#125;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"QuickSort & QuickSelect","date":"2017-04-20T14:15:24.000Z","path":"2017/04/20/QuickSort-QuickSelect/","text":"QuickSort 快速排序 三个要注意的点，都写在程序里了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; /** * @param A an integer array * @return void */ public void sortIntegers2(int[] A) &#123; quickSort(A, 0, A.length - 1); &#125; private void quickSort(int[] A, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int left = start, right = end; // key point 1: pivot is the value, not the index int pivot = A[(start + end) / 2]; // key point 2: every time you compare left &amp; right, it should be // left &lt;= right not left &lt; right while (left &lt;= right) &#123; // key point 3: A[left] &lt; pivot not A[left] &lt;= pivot while (left &lt;= right &amp;&amp; A[left] &lt; pivot) &#123; left++; &#125; // key point 3: A[right] &gt; pivot not A[right] &gt;= pivot while (left &lt;= right &amp;&amp; A[right] &gt; pivot) &#123; right--; &#125; if (left &lt;= right) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; left++; right--; &#125; &#125; //退出循环时，应该是right&lt;left的 //一种可能是right + 1 = left //还有一种是right + 2 = left,两个中间有一个数（left++,right--同时触发时） //但是这不影响下面递归排序，中间那个肯定还是在中间的。 quickSort(A, start, right); quickSort(A, left, end); &#125;&#125; qucikSelect选一个排序数组的第K个数，基本思想类似快排，先随机选pivot，然后排序，左边都小于pivot，右边都大于pivot，推出循环是right&lt;left。如果K大于left呢，说明K在右边，就递归选择右边就好了（但是记得减去左边扔掉的数），如果k小于right呢,说明K在左边，递归调用左边即可。 例题如下： 215. Kth Largest Element in an Array注意：在left和right交换的那个if语句里，交换完成后要left++,right--，多次在这里出错超时，一定不要忘！！！ 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; if (nums == null || nums.length &lt; k) return 0; return quickSelect(nums, 0, nums.length - 1, k); &#125; private int quickSelect(int[] nums, int start, int end, int k) &#123; if (start &gt;= end) &#123; return nums[start]; &#125; int left = start, right = end; int pivot = nums[(start + end) / 2]; while (left &lt;= right) &#123; while (left &lt;= right &amp;&amp; nums[left] &gt; pivot) &#123; left++; &#125; while (left &lt;= right &amp;&amp; nums[right] &lt; pivot) &#123; right--; &#125; if (left &lt;= right) &#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; //一定不要忘！！！！！ left++; right--; &#125; &#125; if (start + k - 1 &lt;= right) &#123; return quickSelect(nums, start, right, k); &#125; else if (start + k - 1 &gt;= left) &#123; return quickSelect(nums, left, end, k - (left - start)); &#125; else &#123; //此为right和left中间还有一个元素的特殊情况（K正好在这个元素） return nums[right + 1]; &#125; &#125;&#125; 414. Third Maximum Number 上面题的简化版，只让找数组（非空）中第三大的数（注意是不重复的）。如果数组没有第三大的，那么返回最大的。 思路：刚开始想的是开一个长度为3的数组，然后每次跟数组中最小的比较，如果大于最小的，替换即可。后来发现这样数组初始化时不好处理重复数据，如果前三个是{1，1，1}就蛋疼了，不能把重复数据进入数组才行。 后来看答案不需要数组，直接三个Integer对象表示前3大的数，按条件更新即可。需要注意的一点就是Integer对象判断值相等应用equals函数，不能用==，==只能判断引用相等否。 12345678910111213141516171819202122232425public class Solution &#123; public int thirdMax(int[] nums) &#123; Integer max1 = null; Integer max2 = null; Integer max3 = null; for (Integer n : nums) &#123; //Integer对象，这里不能用==, ==比较对象的引用，equals比较值 if (n.equals(max1) || n.equals(max2) || n.equals(max3)) &#123; continue; &#125; if (max1 == null || n &gt; max1) &#123; max3 = max2; max2 = max1; max1 = n; &#125; else if (max2 == null || n &gt; max2) &#123; max3 = max2; max2 = n; &#125; else if (max3 == null || n &gt; max3) &#123; max3 = n; &#125; &#125; return max3 == null ? max1 : max3; &#125;&#125; 75. Sort Colors 给定一个序列，含有0，1，2。0代表red。1代表white。2代表blue。将数组按红白蓝的顺序排序。不允许用库中的排序函数 思路：用一个i指针从左到右扫描，r记录红得个数，b记录蓝的个数，如果nums[i] == 0的话，就把r和i交换，并把r加1；如果是1，就不做，i++；如果是2，就把它换到最后边，并把b++。（每次r++后定位的就是下一个没排好的地方，如果是红，就搁到r，把r往后移，如果是1，r不动，等i碰到0的时候会换到r这个位置的。） 要注意两点，如果nums[i] == 2，把2换到后面的时候，i–，因为不知道换回来的这个是啥，要重新判断。第二，i应从0到length - b而不是到最后，后面的已经排好了，就不要再去交换了。 123456789101112131415161718192021222324252627public class Solution &#123; public void sortColors(int[] nums) &#123; if (nums == null) &#123; return; &#125; int i; // r和b记录red和blue的个数。因此第一个不是r的下标就是r，第一个不是b的下标为len-1-b; int r = 0, b = 0; for (i = 0; i &lt; nums.length - b; i++) &#123; if (nums[i] == 0) &#123; swap(nums, i, r); r++; &#125; else if (nums[i] == 2) &#123; swap(nums, i, nums.length - 1 - b); b++; i--; &#125; &#125; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; Sort Colors II(LintCode) Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k. 思路：号称彩虹排序的。也是快排思想，不同的是pivot是选一个中间的颜色。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public void sortColors2(int[] colors, int k) &#123; if (colors == null || colors.length &lt; k) &#123; return; &#125; helper(colors, 0, colors.length - 1, 1, k); &#125; private void helper(int[] colors, int start, int end, int colorFrom, int colorTo) &#123; //递归终止条件，两个都终止 if (start &gt;= end) &#123; return; &#125; if (colorFrom == colorTo) &#123; return; &#125; int i = start; int j = end; int midColor = (colorFrom + colorTo) / 2; while (i &lt;= j) &#123; while (i &lt;= j &amp;&amp; colors[i] &lt;= midColor) &#123; i++; &#125; while (i &lt;= j &amp;&amp; colors[j] &gt; midColor) &#123; j--; &#125; if (i &lt;= j) &#123; int temp = colors[i]; colors[i] = colors[j]; colors[j] = temp; //不要忘！！！ i++; j--; &#125; &#125; helper(colors, start, j, colorFrom, midColor); helper(colors, i, end, midColor + 1, colorTo); &#125;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"360暑期实习面试复盘","date":"2017-04-15T11:54:33.000Z","path":"2017/04/15/360暑期实习面试复盘/","text":"时间：2017.4.14，面试时间约一个小时 地点：360大厦 岗位：360人工智能研究院机器学习岗 简历：机器学习简历 感觉：略惨，还有很多地方需要加强 这算是参加的第一次暑期实习的大规模面试吧！整个一个大屋子，很多个面试桌和面试官，去了等待叫号，会告诉你去哪个面试桌面试。感觉到这么大的场景中还多少有一点紧张，一面大概45分钟到一个小时，二面比较快，半个小时到40分钟的样子吧。 一面一面上来先自我介绍。然后开始直奔主题问项目，给详细解释了RBM的移动通信项目，讲了原理，我们的做法等等，但是感觉面试官应该不是研究这个的，因此也不是特别知道。一些地方讲不明白的会重复给面试官说。其中讲了RNN的原理，然后又问了不了解RNN的一些变种。我说可以讲一下LSTM，给他画了一下LSTM的cell结构以及各种公式，搞定。 有两个问题需要注意一下，第一个问题是面试官提到了baseline问题，说我们项目也没有拿其他方法做一个baseline，就直接做的吗？这个问题回答的不好，其实可以回答我们的baseline是用模糊时间序列去做的。第二个问题是项目是怎么去优化的，我只是说单纯就是去调参，找到更好的方式。 然后就是写算法题。第一题为如何在一个很大数据量中找出最大的前n个数？典型TopK问题，明知道在阿里被问了，这次知道了用堆，但是到自己写的时候还是不会写，尴尬。一定一定要把这题搞明白！！！！实在写不出来就换了一道题，如何在一个有序数组中查找一个数？二分查找，写完，搞定。 最后还问了一嘴会不会tensorflow，我说不会，实验室真的没条件，无能为力啊，面试官也就表示理解。 整体就这些，然后问我有没有问题要问他的。不表。一面结束，出门等着。 二面等了大概5到10分钟吧，挺快的，就开始二面了。二面面试官略严肃，感觉是一个很牛的技术宅。当时看到第一眼就感觉要挂，果不其然。。。上来自我介绍都没有，直接问：我希望你给我讲一个你的项目，这个项目最能体现你的能力，你所学的所会的东西，以及你在项目中扮演的角色。那就开始讲我的RBM，这个面试官感觉是懂RBM得，因此好讲很多，但是对于我们的处理方式一直有疑虑，反反复复讲了几遍让他搞明白。明白之后觉得我们的项目创新度有，但是真正做的活并不是很多。然后又聊了一些别的，也没有问Machine Learning的基础知识也没让写代码，就完了。最后给我说，你给我说三个你觉得你有把握，值得炫耀的能力或事情吧。我说，第一，学习能力，因为是转行过来的。本科毕业的时候我一行代码都不会写，只写过matlab，整个机器学习都是自己一点点学的。第二，处理问题的能力。第三，写文章写材料的能力。 这样就结束了。 因为面完真的12点多了，没注意，感觉我应该是最后一个，面完他们讨论了几分钟就看到面试官背着书包去吃饭，赶紧截住他问问自己的缺点。首先肯定了我的学习能力，他说他也是转行的，本科是学生物的，博士硬转硬学的，确实很辛苦，因此他明白我这个学习能力还是很强的。然后他说还是我做项目的原因吧，不要做RBM这么冷门的东西，没有公司会用的，多做一些现在比较热门的东西会好一点。心塞啊，我做什么又不是我能控制的，我也想做热门的东西哇~~然后我问怎么都没问编程题啊，他说看我初试成绩比较低，就不想问了。。。尴尬。。。 总之，还行吧，这次觉得项目上还确实有一些问题的，自己还可以把项目搞得更清晰一些，讲的更明白一些。有时间的话，最好加一点RNN或者CNN的项目，会好一点。","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"栈、队列、堆、优先队列的实现","date":"2017-04-14T01:08:29.000Z","path":"2017/04/14/栈、队列、堆、优先队列的实现/","text":"Stack使用链表实现 要实现的功能： pop() 链表头部删除 push() 链表头部插入 size() 压入元素时N+1，删除元素时N-1 isEmpty() 检查N是否为0 12345678910111213141516171819202122232425262728293031323334//链表实现栈public class Stack&lt;Item&gt; &#123; private Node first; // 栈顶元素 private int N; //栈的大小 private class Node &#123; Item item; //存储的值 Node next; //下一个节点 &#125; private boolean isEmpty() &#123; return first == null; // 或者 N == 0; &#125; private int size() &#123; return N; &#125; private void push(Item head) &#123; Node oldfirst = first; first = new Node(); first.item = head; first.next = oldfirst; N++; &#125; private Item pop() &#123; Item item = first.item; first = first.next; N--; return item; &#125;&#125; Queue链表实现 要实现的功能： poll() offer() size() isEmpty() 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 链表实现队列public class Queue&lt;Item&gt; &#123; private Node first; // 队列头的元素 private Node last; // 队列尾的元素 private int N; // 队列长度 private Node &#123; Item item; Node next; &#125; private boolean isEmpty() &#123; return (N == 0); &#125; private int size() &#123; return N; &#125; private void enqueue(Item item) &#123; New oldlast = last; last = new Node(); last.item = item; last.next = null; // 需要判断是否为空，是的话把first和last都要指向新节点 if (isEmpty()) &#123; first = last; &#125; else &#123; oldlast.next = last; &#125; N++; &#125; private Item dequeue() &#123; Node item = first.item; first = first.next; // 判空 if (isEmpty()) &#123; last = null; &#125; N--; return item; &#125;&#125; heap使用数组实现二叉堆（不使用数组的第一个位置） 为什么用数组实现而不用链表： 在插入操作中，链式实现需要一个getInsertNode方法去找插入在哪个结点之下，而在数组中，插入结点的位置下标是依次递增的（完全二叉树），插入操作的向上调整也可以直接根据下标来找父节点（思维和链式一样） 在删除堆顶的操作中，链式实现把lastNode的值赋给堆顶后，还要去找倒数第二个结点来更新lastNode，而在数组里就不需要，直接根据下标就知道哪个是倒数第二个结点，而且也不需要记录lastNode。 删除操作的自上往下调整，左右子节点也可以通过下标来定，这个思路和链式一样，也是用递归，只是改为了下标来移动 需要实现的功能： less() 比较 swap() 交换 swim() 上浮 sink() 下沉 priority queue利用堆实现 要实现的功能： insert() 插入元素 max（） 返回最大元素 delMax() 删除最大元素 isEmpty() size() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 实现priority Queuepublic class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; // 使用一个N+1的数组表示大小为N的堆，第一个位置pq[0]始终为空 // 这样对于节点K，它的父节点的索引就是k/2，它的子节点就是2k和2k+1 private Key[] pq; //基于堆的完全二叉树，数组实现 private int N; // 堆的大小 public MaxPQ(int maxN) &#123; pq = (Key[]) new Comparable[maxN + 1]; &#125; public boolean isEmpty() &#123; return (N == 0); &#125; public int size() &#123; return N; &#125; public void insert(Key v) &#123; pq[N++] = v; swim(v); // 底部(数组末尾)插入v，将v上浮到合适的位置 &#125; //删除最大元素的时候，将数组顶端元素删除并把末尾的放到顶端，减小堆的大小 //然后让这个元素下沉到合适位置 public Key delMax() &#123; Key max = pq[1]; //从根节点得到最大元素 swap(1, N--); // 将其和最后一个个节点交换，并刨除最后一个节点。 pq[N+1] = null; // 防止对象游离 sink(1); // 恢复堆的有序性 return max; &#125; // 辅助方法 private boolean less(int i, int j) &#123; return pq[i].compareTo(pq[j]) &lt; 0; &#125; private void swap(int i, int j) &#123; Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; &#125; private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123; swap(k/2, k); k = k/2; &#125; &#125; // 下沉的时候要考虑下沉到两个节点中更大的那个节点 // k的下个节点的下标是2k和2k+1 private void sink(int k) &#123; while (2 * k &lt; N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; swap(k, j); k = j; &#125; &#125;&#125; 优先队列由一个基于堆的完全二叉树表示，存储于数组pq[1..N]中，pq[0]没有使用。在insert()中，我们将N加一并把新元素添加在数组最后，然后使用swim()恢复堆的秩序。在delMax()中，我们从pq[1]中得到最大的元素返回，然后把pq[N]移动到pq[1]，将N减一并用sink()恢复堆的秩序。同时还将不再使用的pq[N+1]设为null，以便系统回收它所占用的空间。 堆排序首先，从右至左使用sink()函数构造子堆。开始只需要扫描数组一般的元素，因为可以跳过大小为1的子堆。最后我们在位置1上调用sink()方法，扫描结束。 我们的目标是构造一个堆有序的数组并使最大元素位于数组的开头而非函数结束的末尾。 1234567891011121314// heapsort// 将swap()和less()的实现中的索引减一就可得到从a[0]到a[N-1]的排序public static void sort(Comparable[] a)&#123; int N = a.length; for (int k = N / 2; k &gt;= 1; k--) &#123; sink(a, k, N); &#125; // 构造好堆之后，把最大值换到最后，然后堆大小减一 // 把换上来的新值sink下去，恢复堆。 while (N &gt; 1) &#123; swap(a, 1, N--); sink(a, 1, N); &#125;&#125; sink函数的另一种实现： 12345678910111213141516171819202122232425/// restores the heap property on a min-heap that has had the root element/// modifiedfunction reheap(heap) &#123; var parent = 0, end = heap.length, child = 1; // recurse down the minheap, swapping entries as needed to // keep the heap property while (child &lt; end) &#123; // get the index of the smallest child node var right = child + 1; if ((right &lt; end) &amp;&amp; (heap[right] &lt; heap[child])) &#123; child = right; &#125; // if the parent is less than both children, we&apos;re done here if (heap[parent] &lt; heap[child]) break; // otherwise swap, and restore heap property on child node var temp = heap[child]; heap[child] = heap[parent]; heap[parent] = temp; parent = child; child = 2 * parent + 1; &#125;&#125; 附上另一种比较整合的实现，没有把swap和less函数分离出来的代码 堆排序实现","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"Linked List","date":"2017-04-12T13:32:55.000Z","path":"2017/04/12/Linked-List/","text":"当链表的结构发生变化时，就需要使用dummy node，dummy node的值不重要，主要作用在放在链表头部，返回链表头结点是可以直接返回dummy.next; 修改链表顺序206. Reverse Linked List 最基本的链表翻转 1234567891011121314151617public class Solution &#123; public ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode prev = null; while (head != null) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev; &#125;&#125; 92. Reverse Linked List II 给定一个链表和m，n，翻转链表的第m个到第n个节点。 Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 需要使用4个指针。prem保存m前一个节点，mNode是第m个节点（翻转前的第一个节点，翻转后的最后一个节点），prev和head用来翻转链表，翻转完成后，prev是之前n节点的位置（翻转后的第一个节点），head是n后面的节点的位置。因此调整顺序为prem-&gt;prev-&gt;...-&gt;mNode-&gt;head即可。 其中需要注意的一点就是for循环控制的时候，i=m开始，结束条件i&lt;n+1的。 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (head == null || m == n) &#123; return head; &#125; ListNode dummy = new ListNode(0); ListNode prem, mNode; dummy.next = head; head = dummy; for (int i = 1; i &lt; m; i++) &#123; head = head.next; &#125; prem = head; head = head.next; //第m个节点 mNode = head; ListNode prev = null; //翻转链表 for (int i = m; i &lt; n + 1; i++) &#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; //跳出循环时候，prev是nNode的位置，head是n的下一个； mNode.next = head; prem.next = prev; return dummy.next; &#125;&#125; 24. Swap Nodes in Pairs 两两翻转链表，即 1-&gt;2-&gt;3-&gt;4 变为 2-&gt;1-&gt;3-&gt;4 该题最初想的时候陷入了使用size变量计数%2的方法里，后来看discuss发现使用快慢指针的方法可以不用计算就得到奇数项和偶数项，很牛~ 思路1：使用递归 1234567891011public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; &#125;&#125; 思路2：使用快慢指针 新建dummy node, 然后从dummy开始，current记录当前节点，从dummy开始，first指针指向current的下一个节点，second指向下下个节点。current每次前行两步，因此first总是奇数个，second 总是偶数个。这样只需要把first和second交换就可以了。 123456789101112131415161718192021public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while (current.next != null &amp;&amp; current.next.next != null) &#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; second.next = first; current.next = second; current = current.next.next; &#125; return dummy.next; &#125;&#125; 25. Reverse Nodes in k-Group k组翻转链表，给定k，按k个为一组，组内翻转链表，不足k个的就不翻转 即：1-&gt;2-&gt;3-&gt;4-&gt;5 for k=2 return: 2-&gt;1-&gt;4-&gt;3-&gt;5for k=3 return: 3-&gt;2-&gt;1-&gt;4-&gt;5 这个题其实是24题的升级版本，大思路为设置一个current指针，判断current后面的节点够不够k个，如果够，翻转k个，把current更新到翻转过部分的最后一个，再判断current后面够不够。。 对于需要翻转的部分，使用for循环控制k个，需要4个指针，current指向要翻转部分的前一个节点，start保存翻转部分的头（翻转后的尾），prev和node是用来翻转的两个指针，初始prev指向current，node指向start，当翻转完成，prev是翻转部分翻转前的尾节点也就是翻转后的头节点，node是翻转部分的下一个节点。因此只要调整顺序为current-&gt;prev-&gt;...-&gt;start-&gt;node。该部分翻转完成。然后将current更新到start节点，从node开始下一部分翻转。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; ListNode start = null; ListNode prev = null; ListNode node = null; while (hasK(current.next, k)) &#123; prev = current; start = current.next; node = start; for (int i = 0; i &lt; k; i++) &#123; ListNode next = node.next; node.next = prev; prev = node; node = next; &#125; //此时，start是翻转部分的尾节点，node是翻转部分后面的节点 //current是翻转部分前面的节点，prev是翻转部分的头节点 start.next = node; current.next = prev; current = start; &#125; return dummy.next; &#125; private boolean hasK(ListNode head, int k) &#123; int size = 0; while (head != null) &#123; size++; head = head.next; &#125; return size &gt;= k; &#125;&#125; 61. Rotate List 在k除旋转链表，把后k个放到前面去 Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 该题dubug很久：犯了两个错误，一个是想当然认为k应当比链表长度小，其实有可能大，大的时候应当取余。二是在计算链表长度的时候，我用head指针遍历，遍历完成时候head已经不再是链表头部了，不能再当头部用，应当再赋值回头部才能用！ 思路就是首先看k的值，用k%长度，若结果等于0或是链表长度，则不需要rotate，然后slow和fast指针从dummy开始走，fast先走k步，然后一起同步走，当fast到尾节点（不是null）时，slow到翻转节点的前一个。则slow.next为新头部，把fast.next接上dummy.next再把slow置空即可。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; //因为k有可能大于长度，因此要计算下链表长度 int count = 0; while (head != null) &#123; count++; head = head.next; &#125; //一定记得，如果用head来算长度，算完已经变了null //要恢复成头结点，在这debug好久。。 head = dummy.next; k = k % count; if (k == 0 || k == count) &#123; return head; &#125; for (int i = 0; i &lt; k; i++) &#123; fast = fast.next; &#125; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next; &#125;&#125; 86. Partition List 给定x，配分链表使得前面节点的值小于x，后面节点的值大于等于x，但是两部分不能改变原来的顺序 Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 思路：维护两个链表，dummy和dummy2，原链表从dummy开始，遇到&gt;=x的节点就把它连到第二个链表，然后原链表中删除。最后把dummy和dummy2接起来就可以了。记得记录两个链表得头和尾以便接的时候用。 123456789101112131415161718192021222324public class Solution &#123; public ListNode partition(ListNode head, int x) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode dummy2 = new ListNode(0); head = dummy; ListNode p = dummy2; while (head.next != null) &#123; if (head.next.val &gt;= x) &#123; ListNode temp = head.next; p.next = temp; p = p.next; head.next = head.next.next; &#125; else &#123; head = head.next; &#125; &#125; head.next = dummy2.next; p.next = null; return dummy.next; &#125;&#125; 328. Odd Even Linked List 修改链表顺序使得奇数个的节点的在前，偶数个节点在后，注意是节点第几个的奇偶而不是节点的值是奇偶。不能改变顺序和值。 Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. 思路，维护两个链表，奇数个的连在dummy1后面，偶数个的连在dummy2后面，然后dummy1连上dummy2。注意处理最后一个是奇数个的特殊情况。 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null) return head; ListNode dummy = new ListNode(0); ListNode dummy1 = new ListNode(0); ListNode dummy2 = new ListNode(0); dummy.next = head; ListNode current = dummy; ListNode p1 = dummy1; ListNode p2 = dummy2; while (current.next != null &amp;&amp; current.next.next != null) &#123; ListNode odd = current.next; ListNode even = current.next.next; current = even; p1.next = odd; p1 = p1.next; p2.next = even; p2 = p2.next; &#125; if (current.next != null) &#123; p1.next = current.next; p1 = p1.next; &#125; p1.next = dummy2.next; if (p2 != null) &#123; p2.next = null; &#125; return dummy1.next; &#125;&#125; 删除节点237. Delete Node in a Linked List 只给你要删除的节点，不给头节点，让你删除节点 只要把这个节点的值修改成后一个节点的值，把后一个节点删除即可。 注意: 若给的节点是最后一个节点，此题无解。。。 1234567891011public class Solution &#123; public void deleteNode(ListNode node) &#123; if (node == null || node.next == null) &#123; return; &#125; node.val = node.next.val; node.next = node.next.next; return; &#125;&#125; 19. Remove Nth Node From End of List 删除链表的倒数第n个节点 两个指针，都从dummy开始走，p1先走n步，于是两个指针中间差n个节点。然后同步走，当p1走到null时，p2正好走到要删除的倒数第n个节点。因此，为了删除，让p1.next走到null时，p2.next是要删除的节点，删除即可。 12345678910111213141516171819202122public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (head == null || n &lt;= 0) &#123; return head; &#125; ListNode dummy = new ListNode(0); ListNode p1 = dummy, p2 = dummy; dummy.next = head; for (int i = 0; i &lt; n; i++) &#123; p2 = p2.next; &#125; while(p2.next != null) &#123; p1 = p1.next; p2 = p2.next; &#125; p1.next = p1.next.next; return dummy.next; &#125;&#125; 203. Remove Linked List Elements 删除链表里值等于val的节点 从dummy开始往后循环，如果.next值是要删除的，那么把它删除，但是head不往前走，因为有可能删掉之后下一个还是等于val的。只有.next的值不等于val时，指针往后走。 12345678910111213141516public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; head = dummy; while (head.next != null) &#123; if (head.next.val == val) &#123; head.next = head.next.next; &#125; else &#123; head = head.next; &#125; &#125; return dummy.next; &#125;&#125; 83. Remove Duplicates from Sorted List 删除排序链表里的重复值节点，使得所有节点只出现一次 Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 就从head节点开始（不需要从dummy节点，因为不可能需要删第一个节点），如果head.next跟head相同，删去head.next，不更新head，若不同，更新head。 12345678910111213141516public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; while (head.next != null) &#123; if (head.val == head.next.val) &#123; head.next = head.next.next; &#125; else &#123; head = head.next; &#125; &#125; return dummy.next; &#125;&#125; 82. Remove Duplicates from Sorted List II 删除重复节点，有重复值的节点一个都不保留 Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 思路：维护两根指针，p1从dummy开始走，p2初始为p1的下一个，如果p2和p2.next相等，p2向下走直到p2 != p2.next（这样解决原因主要是考虑到第一个节点就是重复的要删除的情况）时，p1.next = p2.next（这样把所有等于p2的都删了）；如果p2和p2.next不同，p1往下走即可。 12345678910111213141516171819202122public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode p1 = dummy; while (p1.next != null) &#123; ListNode p2 = p1.next; if (p2.next != null &amp;&amp; p2.val == p2.next.val) &#123; while (p2.next != null &amp;&amp; p2.val == p2.next.val) &#123; p2 = p2.next; &#125; p1.next = p2.next; &#125; else &#123; p1 = p1.next; &#125; &#125; return dummy.next; &#125;&#125; 各种变形链表问题141. Linked List Cycle 判断链表有环问题 快慢指针，相遇则有环 142. Linked List Cycle II 判断环的入口 当快慢指针相遇时，head从头部走，slow从相遇点走，一次走一步，当head和slow相遇的点，即为环的入口。 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode slow = head; ListNode fast = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) &#123; while (slow != head) &#123; slow = slow.next; head = head.next; &#125; return head; &#125; &#125; return null; &#125;&#125; 160. Intersection of Two Linked Lists 找两个链表的交点 思路1：先算出两个链表的长度，作差，让长的链表指针先走差不，然后两个指针同步走，当p1 == p2时，即为交点 思路2：将链表的尾部接到其中一个链表的头部，变成了找链表环入口的问题。 234. Palindrome Linked List 判断一个链表是不是palindrome 思路1：翻转链表，然后比对翻转后的和翻转前的一样否。（注意只需要比对前一半即可） 思路2：快满指针，慢指针走的时候入栈，快指针到达尾部，慢指针到中点，继续往下走，比对慢指针和栈中pop()出来的元素是否相同。需要注意的一点就是，若是奇数个，记得慢指针跳过中间节点再比对 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public boolean isPalindrome(ListNode head) &#123; if (head == null) return true; ListNode slow = head; ListNode fast = head; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); //这里是fast != null &amp;&amp; fast.next != null //而不是fast.next 和 fast.next.next while (fast != null &amp;&amp; fast.next != null) &#123; stack.push(slow); slow = slow.next; fast = fast.next.next; &#125; //奇数情况跳过中间 if (fast != null) &#123; slow = slow.next; &#125; while (slow != null) &#123; ListNode cur = stack.pop(); if (slow.val != cur.val) &#123; return false; &#125; slow = slow.next; &#125; return true; &#125;&#125; 138. Copy List with Random Pointer 深拷贝一个带随机指针的链表 思路1： 比较直观，直接利用HashMap，key存原先链表的节点，value存复制的链表节点，先复制节点，再复制next和random指针，最后return即可 思路2： 先复制节点，在每个节点后面加入复制的节点，1-&gt;2-&gt;3变成1-&gt;1&#39;-&gt;2-&gt;2&#39;-3-&gt;3&#39; 把复制的节点的random指针复制了（head.next是复制的节点，head.next.next是原链表的下一个节点）。这里有个要注意的地方：random有可能指向空，因此要if语句特殊处理下，不然会空指针异常。 把大链表拆开，拆成两个，一个原来的，一个复制的。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) return null; RandomListNode dummy = new RandomListNode (0); dummy.next = head; //1.make copy of each node while (head != null) &#123; RandomListNode next = head.next; RandomListNode copy = new RandomListNode(head.label); head.next = copy; copy.next = next; head = next; &#125; //2.assign random pointers of copy nodes head = dummy.next; while (head != null &amp;&amp; head.next != null) &#123; if (head.random == null) &#123; head.next.random = null; &#125; else &#123; head.next.random = head.random.next; &#125; head = head.next.next; &#125; //3.split the linkedlist to original and copy head = dummy.next; RandomListNode copy = new RandomListNode(0); RandomListNode p = copy; while (head != null &amp;&amp; head.next != null) &#123; p.next = head.next; head.next = head.next.next; p = p.next; head = head.next; &#125; p.next = null; return copy.next; &#125;&#125; Insert into a Cyclic Sorted List(LintCode) 在一个排序循环链表中插入一个节点 思路：关键考虑边界情况，如果都没有的话，要把插入节点的next指向自己才行。然后考虑两种情况：1是插入的点是大于链表最小值，小于链表最大值的，那么找到合适位置插入即可；2是如果小于链表最小值或者大于链表最大值呢，就要找到链表最大值和最小值接起来的那个地方插入。 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; /** * @param node a list node in the list * @param x an integer * @return the inserted new list node */ public ListNode insert(ListNode node, int x) &#123; // Write your code here ListNode ins = new ListNode(x); if (node == null) &#123; ins.next = ins; return ins; &#125; if (node.next == node) &#123; node.next = ins; ins.next = node; return ins; &#125; ListNode p = node; ListNode next = null; while (p.next != node) &#123; if (x &gt;= p.val &amp;&amp; x &lt;= p.next.val) break; if ((p.next.val &lt; p.val) &amp;&amp; (x &lt; p.next.val || x &gt; p.val)) break; p = p.next; &#125; ins.next = p.next; p.next = ins; return ins; &#125;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"K-NN","date":"2017-04-12T02:58:44.000Z","path":"2017/04/12/K-NN/","text":"实质：对特征空间的划分 输入：实例的特征向量 输出：实例的类别标签（可以多类）或者回归问题为数字 性质：监督学习方法，可分类可回归 特点：没有显式的训练过程，属于懒惰学习(lazy learning)，在训练阶段只是把样本保存起来，训练时间开销为0，待收到样本时再进行处理 三个要素： K的值（K=1时成为最近邻法） 距离度量（欧式距离） 决策规则（分类任务：多数表决，回归任务：平均值） 算法描述 根据给定的距离度量，在训练集中找出离x最近的K个点，涵盖这K个点的邻域记做\\(N_K(x)\\) 在\\(N_K(x)\\)中根据决策规则（如多数表决），确定x的类别y 三要素之K的值 当K=1时，变为最近邻法，即对于输入x，将训练集中与x最近的点的类作为x的类。 增加K的值，使模型变得简单，当K=N时，就变成了整体的多数表决。容易欠拟合。 减少K的值，使模型变得复杂，对近邻更加敏感，如果近邻点是噪声，容易判错，因此容易过拟合。 一般采取交叉验证法来确定K的值。 三要素之距离度量常用距离：($l$为第$l$个特征) \\[L_p=(x_i,yi)=(\\sum^n{l=1}{|x^{(l)}_i-x^{(l)}_j|}^p)^{\\frac{1}{p}}\\] 当p=2时，为欧式距离： \\[L_2=(x_i,yi)=(\\sum^n{l=1}{|x^{(l)}_i-x^{(l)}_j|}^2)^{\\frac{1}{2}}\\] 当p=1时，为曼哈顿距离： \\[L_1=(x_i,yi)=\\sum^n{l=1}{|x^{(l)}_i-x^{(l)}_j|}\\] 当p=$\\infty$时，为各个坐标距离的最大值： \\[L_1=(x_i,y_i)=\\max_l{|x^{(l)}_i-x^{(l)}_j|}\\] K近邻法的实现当数据集比较小时，可以采用线性扫描。但是如果数据集很大，很浪费时间，可以使用kd树（kd tree）方法实现K近邻。kd树是一个二叉树，是对K维空间的划分。","tags":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://yoursite.com/tags/MachineLearning/"}]},{"title":"网易传媒技术部数据挖掘面试复盘","date":"2017-04-07T04:11:19.000Z","path":"2017/04/07/网易传媒技术部数据挖掘面试复盘/","text":"时间：2017.4.6，面试时间不到一个小时 地点：网易北京研发中心 岗位：传媒技术部，数据挖掘实习生 简历：机器学习简历 感觉：还好 这次面试比较简短，以至于还没反应过来就面试结束了。然后面试官跟我说过了的话一星期会有人通知，我说是通知过来二面吗，他说不是，没有二面，应该就是直接hr给我打电话了。有点小意外。 约得两点的面试，结果面试官有事，2点20才开始的面试，大概3点左右就结束了。上来先自我介绍，然后问了华为的项目，讲了做项目的经过，然后给他讲了RBM还有DBN的知识。问了为什么DBN可以防止梯度迷散。然后就继续问了能不能推一下BP神经网络，给他推了简单的3个节点的BP神经网络。 然后说做一道算法题把，我说好，结果他说能不能写一个快排。我说用我自己喜欢的语言吗，他说你会C++吗，不会，于是让用java写的。 比较基础，也没啥的，很快就写完了。感觉只是为了考我会不会写程序，并不是考算法。 写完之后给他讲了讲，他说可以。以为他要再出一道，结果他说可以了，今天就先到这儿了，回去等通知吧。稍微有点惊讶，以为会问的更多一些，不过感觉还好吧。虽然短点，还不错。 就是这些。","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"百度系统部机器学习面试复盘","date":"2017-03-23T12:05:47.000Z","path":"2017/03/23/百度系统部机器学习面试复盘/","text":"时间：2017.3.23，面试时间约一个小时 地点：百度科技园2号楼 岗位：百度系统部机器学习岗，实习岗 简历：机器学习简历 感觉：2分吧，被虐的体无完肤 过程复盘这次面试面了1个小时零10分钟左右吧，是最近面的很短的一次，却是问问题最多的一次，也是不会的东西最多的一次。彻底被问跪~而且是两个面试官，交叉问，也是醉了。怎么讲，问了很多比较底层比较原理的东西吧，用古人的话说，只知道然是不够的，还会问很多所以然。但是怎么说，觉得他们问的很多东西，也并不普遍，有点过于追求难度和怪异了，不知道什么感觉，先把不会的知识点记下来补充吧。 由于节奏快，就把能记起来的，被问倒的点记下来。 RBM刚上来，开始问项目，第一个项目，问了RBM的，CRBM和RBM不同的地方在哪里，为什么可以处理时域数据，CRBM和RNN在处理时域数据上的不同是什么。然后问了RBM的能量函数。后来问了玻尔兹曼分布，这个我是真没听过，可能是数学基础上的一些东西，然后问了一个叫“Ising Model”的东西，答曰不懂。(查了下，玻尔兹曼分布是纯物理模型，或是统计力学模型，Ising Model是也纯物理理论的模型，这玩意问我干嘛。。我又不是学物理的) RNN 与 LSTM然后问了LSTM，RNN就问了缺点是啥，答曰梯度迷散，我说我可以讲一下，他说不用，直接讲LSTM的cell结构吧，给他画了LSTM的cell结构，然后继续问给你一个节点的什么什么样例，让我推导一下更新公式，。。。不会 LR结束之后问了第二个项目，问起来LR，问的也是偏数学，我忘记怎么描述的，一个问题是为什么LR可以输出概率，在数学上的解释。我解释了半天好像也没说到点子上，然后就给他推公式，推出损失函数来，问这个损失函数在数学上叫什么，不会，说了几个也不对。。。 RF然后问随机森林，问假设我给你N个特征，要构造100颗树的随机森林，说一下构造过程。这里说的也不好，确实对过程理解不深。后来就转向问bagging的方法，问是怎么采样的，然后问bagging和boosting 的区别是什么 Linux问起Linux，问我shell编程掌握咋样，出了一道题是 你写了一个python程序，你要运行它，发现端口被占用了，用什么命令找到这个端口 然后问了参加比赛一般数据怎么处理，答曰pandas，问有没有用Linux处理过，我说没有，问了awk，我说也不会 sql问sql掌握到什么程度，我说基本语句都会。他问如何分组过滤，我说group by having，然后问你知道执行顺序吗，比如一条语句select * from table where ... group by ... having....，这条语句的执行顺序知道吗，答曰不知道。然后问了索引熟悉吗，答曰不懂。。。 SVM然后问起SVM了解多少，我说知道基本原理。他让讲对偶然问题，讲不出来，然后问使用核函数是为了解决什么问题，瞎扯了一些。。（SVM这块确实挺弱的，因为确实现在日薄西山） 算法与数据结构 给一个40亿的字符串，里面没有相同的字符，内存600M，问如何找到等于target的这个字符串 实现一个优先队列 问平衡树、红黑树、二叉搜索树这些数据结构的出现是为了解决什么问题 写堆排序 写归并排序 擦擦啊，就最后归并排序会写，前面全不会，都在瞎扯。怎么说，这次的数据结构与算法直接就略过了基础题和简单题，比如排序，上来就直接问堆排序也是无语，然后问了很多底层原理的问题，我真的不懂。注重底层原理与实现，其实考察的确实都是数据结构，对一些算法考察的还少一点。整体有难度吧。 总结怎么说，这次面试确实有一些难度，简单基础大路边的上的问题直接就不问了，转而追求原理性、深层次的问题，尤其是RBM那两个统计力学纯物理概念我也是服，RBM上还是为数不多被问倒的时候（上一次是Gibbs采样）。数据结构与算法也是问的很底层，很原理，觉得计算机专业可能会好一些，对于我这种半路出家的，很难。再就是对于模型，这次两人给我的感觉就是当我答上问题来了，立马会有更难更深的问题，一直要把我问倒为止，哪怕使用很深很偏的问题，挺无语的。这次还是有很多问题要加强吧，总结如下： SVM原理，核函数，对偶问题 RF的实现过程 LR的数学基础与概率解释 LSTM的推导与更新，只知道cell结构是不够的 sql的命令执行顺序，还有索引 Linux全部，包括awk 平衡树、红黑树、二叉搜索树为了解决什么问题 一些高级数据结构的实现（如优先队列） 堆排序 诶。。。。。。。。。。好难。。。。。。加油吧~任重道远吶。。。。","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"蓄水池抽样","date":"2017-03-20T13:56:57.000Z","path":"2017/03/20/蓄水池抽样/","text":"转载自： 伯乐在线 引言：众所周知，想要面试一个统计学家和软件工程师的合体——数据工程师——是件很难的事情。我在面试中常使用的方法是：提出即需要算法设计，又需要一些概率论知识的问题，来考察面试者的功底。下面就是在硅谷非常流行的例子： “给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。” 当面对这样一个问题的时候，我们首先应该做的是：镇静。你的面试官并没有玩你，相反他可能特别想雇你。他可能正在为无尽的分析请求烦恼，他的ETL流水线已经不在工作，已有的机器学习模型也不再适合。他正想要你这样一个聪明人进来帮忙，他希望你答出来。 第二件要做的事情是：不要在没有深入思考的情况下盲目作答。假设你的面试官读过Daniel Tunkelang的关于数据工程师的面试建议，那么这个面试题很可能就是他工作中实际遇到的问题。所以如果像下面一样随便回答，很可能会令你的面试官失望。 “我会首先将输入存到一个列表中，统计出数据流中数据的个数，在读取结束之后随机选取一个”（大哥， 你没看见题目已经说了，数据流长度很大或者未知么，不怕你的内存装不下？） 第三件要做的事情是：从小例子开始分析。大部分的人都更容易解决具体问题（而不是抽象问题），最开始你设计的小例子可能和最后的问题之间相去甚远，但是却能启发你对问题的理解，给你灵感。 蓄水池算法如前面所说，对这个问题我们首先从最简单的例子出发：数据流只有一个数据。我们接收数据，发现数据流结束了，直接返回该数据，该数据返回的概率为1。看来很简单，那么我们试试难一点的情况：假设数据流里有两个数据。 我们读到了第一个数据，这次我们不能直接返回该数据，因为数据流没有结束。我们继续读取第二个数据，发现数据流结束了。因此我们只要保证以相同的概率返回第一个或者第二个数据就可以满足题目要求。因此我们生成一个0到1的随机数R,如果R小于0.5我们就返回第一个数据，如果R大于0.5，返回第二个数据。 接着我们继续分析有三个数据的数据流的情况。为了方便，我们按顺序给流中的数据命名为1、2、3。我们陆续收到了数据1、2和前面的例子一样，我们只能保存一个数据，所以必须淘汰1和2中的一个。应该如何淘汰呢？不妨和上面例子一样，我们按照二分之一的概率淘汰一个，例如我们淘汰了2。继续读取流中的数据3，发现数据流结束了，我们知道在长度为3的数据流中，如果返回数据3的概率为1/3,那么才有可能保证选择的正确性。也就是说，目前我们手里有1,3两个数据，我们通过一次随机选择，以1/3的概率留下数据3，以2/3的概率留下数据1.那么数据1被最终留下的概率是多少呢？ 数据1被留下：（1/2）*(2/3) = 1/3 数据2被留下概率：（1/2）*(2/3) = 1/3 数据3被留下概率：1/3 这个方法可以满足题目要求，所有数据被留下返回的概率一样！ 因此，我们做一下推论：假设当前正要读取第n个数据，则我们以1/n的概率留下该数据，否则留下前n-1个数据中的一个。以这种方法选择，所有数据流中数据被选择的概率一样。简短的证明：假设n-1时候成立，即前n-1个数据被返回的概率都是1/n-1,当前正在读取第n个数据，以1/n的概率返回它。那么前n-1个数据中数据被返回的概率为：(1/(n-1))*((n-1)/n)= 1/n，假设成立。 这就是所谓的蓄水池抽样算法。它在分析一些大数据集的时候非常有用。你可以在这里找到Greg写的关于蓄水池抽样的算法介绍。本文后面会介绍一下在Cloudera ML中使用的两种：分布式蓄水池抽样和加权分布式蓄水池抽样。 （注：Cloudera ML是基于hadoop的数据分析和挖掘开源项目） LeetCode 382 Linked List Random Node Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 蓄水池抽样： 当随机到的数为0时，返回蓄水池中的那个节点，概率为1/(n+1) 当链表长度为1时，random.randint(0, 0)恒等于0，因此抽到第1个元素的概率为1 假设抽取前n个元素的概率相等，均为1/n 当抽取第n+1个元素时：若random.randint(0, n)等于0，则返回值替换为第n+1个元素，其概率为1/(n+1)；否则，抽取的依然是前n个元素，其概率为1/n * n/(n+1) = 1/(n+1) 代码： 123456789101112131415161718192021222324252627282930import randomclass Solution(object): def __init__(self, head): \"\"\" @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode \"\"\" self.head = head; def getRandom(self): \"\"\" Returns a random node's value. :rtype: int \"\"\" head = self.head n = 0 while head: if random.randint(0, n) == 0: res = head.val head = head.next n += 1 return res# Your Solution object will be instantiated and called as such:# obj = Solution(head)# param_1 = obj.getRandom()","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"GBDT","date":"2017-03-16T08:58:20.000Z","path":"2017/03/16/GBDT/","text":"本文总结自知乎专栏文章： Learn R | GBDT of Data Mining 是啥GBDT（Gradient Boosting Decision Tree）是一种基于迭代所构造的决策树算法。该算法生成多棵决策树，并将所有树的结果进行汇总来得出结果，将决策树和集成思想进行了有效的融合。 三个重点 GBDT中的DT是回归树而不是决策树 GB–梯度提升 GBDT中的shrinkage–缩减 GBDT之回归树GBDT中用的决策树并不是分类决策树，而是回归决策树。GBDT累加所有树的结果作为最终结果。 作为对比，简要回顾下分类树的运行过程：以ID3为例，穷举每一个属性特征的信息增益值，每一次都选取使信息增益最大的特征进行分枝，直到分类完成或达到预设的终止条件，实现决策树的递归构建。 回归树的运行流程与分类树基本类似，但有以下两点不同之处： 第一，回归树的每个节点得到的是一个预测值而非分类树式的样本计数，假设在某一棵树的某一节点使用了年龄进行分枝（并假设在该节点上人数&gt;1），那么这个预测值就是属于这个节点的所有人年龄的平均值。 第二，在分枝节点的选取上，回归树并没有选用最大熵值来作为划分标准，而是使用了最小化均方差，即\\(\\frac{\\sum_{i=1}^{n}{} (x_i-\\bar{x} )^2}{n}\\) 。这很好理解，被预测出错的次数越多，错的越离谱，均方差就越大，通过最小化均方差也就能够找到最靠谱的分枝依据。 一般来讲，回归树的分枝不太可能实现每个叶子节点上的属性值都唯一，更多的是达到我们预设的终止条件即可（例如叶子个数上限），这样势必会存在多个属性取值，那么该节点处的预测值自然就为基于这些样本所得到的平均值了。 GBDT之梯度提升梯度提升是一种理念而非算法，其基本思想是沿着梯度方向训练一系列弱分类器并以一定的权重组合起来，形成最终的强分类器。 这一系列弱分类器的训练方式便是GBDT的核心所在：每一棵树学习的是之前所有树结论和的残差 “Boosting，迭代，即通过迭代多棵树来共同决策。这怎么实现呢？难道是每棵树独立训练一遍，比如A这个人，第一棵树认为是10岁，第二棵树认为是0岁，第三棵树认为是20岁，我们就取平均值10岁做最终结论？当然不是！且不说这是投票方法并不是GBDT，只要训练集不变，独立训练三次的三棵树必定完全相同，这样做完全没有意义。之前说过，GBDT是把所有树的结论累加起来做最终结论的，所以可以想到每棵树的结论并不是年龄本身，而是年龄的一个累加量。GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。这就是Gradient Boosting在GBDT中的意义。” 关于梯度提升的算法推导，请看李航老师《统计学习方法》中8.3节，提升树。 GBDT之shrinkage Shrinkage是GBDT的第三个基本概念，中文含义为“缩减”。它的基本思想就是：每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。换句话说缩减思想不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，只有通过多学几棵树才能弥补不足。 Shrinkage仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分（step*残差）逐步逼近目标，step一般都比较小，如0.01~0.001（注意该step非gradient的step），导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，Shrinkage为每棵树设置了一个weight，累加时要乘以这个weight，但和Gradient并没有关系。这个weight就是step。就像Adaboost一样，Shrinkage能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。 参考GBDT（MART） 迭代决策树入门教程 | 简介 决策树与迭代决策树（GBDT）","tags":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"http://yoursite.com/tags/MachineLearning/"}]},{"title":"阿里巴巴阿里妈妈广告部门面试复盘","date":"2017-03-08T00:57:32.000Z","path":"2017/03/08/阿里巴巴阿里妈妈广告部门面试复盘/","text":"时间：2017.3.7，面试时间约两个半小时（一面） 地点：望京阿里巴巴绿地中心 岗位：阿里妈妈广告算法岗，实习岗 简历：网申简历 + 机器学习简历 感觉：面完蛮开心的，4分？ 过程复盘其实是阿里巴巴暑期实习校招内推的面试，特别早，3月份就面了，整体感觉还不错，因为她问的知识点，问题上答得自己感觉还可以，算法想的有点坎坷，在提示下写出来的。还有就是对广告算法了解的实在不够多。 其实开头略尴尬，只收到了电话面试的通知，木有收到短信或者邮件，导致我来到望京绿地中心了都不知道给谁打电话，回电话是阿里巴巴北京的主机号，也是醉了，辗转到前台接上面试官的电话，才找到了人继续面试。尴尬的一笔。 面试官是个妹子，很亲和。上来就开始，都木有自我介绍就开始问。先问了问个人信息，还问了是不是保研的之类。然后问常用的模型是什么。然后就说到了LR，让我给写LR的损失函数，老生常谈，写公式，推公式，写概率、损失函数、梯度下降用来最优化，然后更新公式，还可以，没有卡壳。然后她问了梯度下降能不能达到全局最优解，答曰不能，容易陷入局部最优，相比之下需要使用随机梯度下降(SGD)，这里讲的不好，没讲清楚，不过她也很好的表示理解，问每次是对什么进行梯度下降，答曰对一个随机样本梯度下降，她说OK~就过了 然后问你研究神经网络应该知道batchdata，一般是怎么设定这个batchsize的。答曰按直觉。。尴尬。她说举个例子，就给她举了项目里调参数的例子，她表示懂了。过程中给她讲了RBM，DBN，同时也被问到了RNN，给她讲了RNN的原理。后来又问到了有没有使用过caffe或者tensorflow的经验呢巴拉巴拉，答曰只了解一点，没有用过，实验室没条件。 然后就问到了BP算法。我说确实时间有点久了，我可以试着推一下。确实有点想不起来，表现的不是很好，不过大体意思能说明白。考前应该好好看一下的，当时花了那么多时间推BP，丢分简直不应该。然后她问了某一个节点的梯度跟哪些节点有关系，答曰上一层跟它有连接的节点。然后就过了 然后呢，就开始做题了。 算法题 给你一个广告的一天的日志，里面是一条一条的query，让你统计这个日志里数量最多的前K个query，先不考虑数据量很大的问题。 然后follow up就是，如果数据量很大，内存如果无法一下都读取，怎么办？ 先跟我聊思路和复杂度，我说用一个hashmap，把每一个query的数量统计下来，O(n)的复杂度，key的值是query，value的值是query出现的数量，然后她问key就是存string吗，还是什么，我说现在想的就是这样。然后她问怎么取前K个，我说排序。她说能不能有小于O(nlogn)的方法。其实这里被绕进去了，很好想到的问题，跟她饶了好久，总是在排序上。其实开一个K的hashmap，然后遍历总得hashmap，如果当前的query的值大于K个的最小值，那么我就把这个替换过去，这样遍历完了就得到了前K个数量的query了 然后开始写代码，我说用python行吗，她说她不会，我心说那我更得用python了哈哈哈哈哈，然后我就深沉的说没事，我给你讲思路，她说行。然后就写，写完就讲。讲完OK，过…… 然后，就follow up……问如果数据量特别大，大到那个日志内存都读不完，怎么办？ 刚开始被问懵了，其实还是没见过这种题。她一直在引导我，可是我就是不开窍。其实就是分块，这个我倒是想到了。没想到的是，按query分块，然后分块统计，，每次取那个总得大dict来比较的时候只取出与query有关的key值不就可以了嘛。 模型构建然后继续就是问了些特征工程的问题。 说如果我们能给你很多用户的购买信息，让你设计模型评估用户的购买力，你会设计哪些特征？ 开放性的问题，回答还可以。设计年龄啊，性别啊，购买时间，在页面停留时间等等特征 然后问了如果让你评估用户是否会去点广告，广告的转化率问题，你怎么设计特征？ 还是开放新问题，在上面问题上讨论了下，也没有对错反正，想不太起来了，大体就是那些 最后就是你有什么问题要问我没~ 老生常谈，问了部门情况(就是广告的业务部门，看效果的)，能接触到什么（hadoop肯定可以，但是貌似不会接触到很多深度学习的东西，比如tensorflow, caffe什么的），常用的语言是什么（线上会是java，线下自己弄就无所谓了，也有写python的）。然后就是实习时间啦，转正啦之类的，没有很多有营养的东西，大概就是酱紫。 然后就是送我出来，等通知了。","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"面试复盘：网易+搜狗","date":"2017-03-08T00:56:00.000Z","path":"2017/03/08/面试复盘：网易-搜狗/","text":"网易机器学习（深度学习）岗 时间：2017.3.2，面试时间约两个小时（一面） 地点：网易北京研发中心 岗位：网易传媒技术部，机器学习/深度学习 实习岗 简历：应聘深度学习岗位简历 感觉：还不错，4分 首先就是自我介绍，不表，没营养。。 然后就开始做题。。。。 算法题先写二分查找：尴尬的是start = mid写反了，写成了mid = start 第二题是二叉树两个节点的公共祖先，我说这个题没遇到过，可能不会，然后又改成求两个链表的交点，面试官说这两个题是一样的，会一个就都会了。 当时写了一个通过python列表，把各节点的值加入列表里从后面开始找的算法，是错误的，如果所有节点的值都是1，怎么办，算法没法运行了。 后来新的思路： 首先正向考虑，交点之后的链表长度是相等的，区别在于交点之前的链表。因此先求两个链表的长度，求长度差。让长的链表的指针先走长度差个节点，然后两个指针一块往下走，当两个链表的节点相同时，即为交点。 把一个链表的尾部跟另一个链表的头连起来，就变成了链表有环的问题，就变成了如何找入环的第一个节点的问题，但是当时这个找第一个节点的算法答得不好 然后做题完成，问了简历上的项目，比较详细的问了DBN与RBM，RBM的能量函数，条件概率公式，如何构成DBN； 问了上海联通大赛的一些问题，整个做题过程，用了哪些特征，哪些特征影响大 然后天池大赛的用了哪些特征，用过哪些模型 问除了DBN，深度学习还了解什么，我说了解一些RNN，给他简单讲了一下原理，然后是LSTM的简单原理 问CNN了解吗，讲了一些CNN的简单原理，问了CNN的优缺点 项目的MATLAB代码的一些简单交流，然后问python的theano接触过多少，问用theano和MATLAB的区别是什么(theano很多东西封装好了，可以直接使用，比如梯度下降、归一化啊之类的，MATLAB要完全自己写) ps: python的封装性优于matlab也是刚刚问题中提到的一些，刚开始回答的这个，面试官说这是python的特点而不是theano的特点 还问在nlp方面有什么了解的吗？我说会一点定啊word2vector，面试官瞬间很感兴趣，结果我就懂一点皮毛，说了下就算了。然后他说这些知识不会没事儿，可以再学。 一面暂时就想到这些。当时面完1点了，然后有人过来带我去吃饭，说是吃完饭接着面，但是我两点有搜狗的面试，只得拒绝，再约时间二面。 搜狗数据挖掘岗 时间：2017.3.2，面试时间约1个小时（一面） 地点：搜狐网络大厦 岗位：搜狗网页搜索部 数据挖掘实习岗 简历：应聘机器学习岗位简历 感觉：不好，2.5分吧 总体感觉不理想，可能上午面了一上午，有点累，而且面试官刚开始语气特别冲，给人一种压迫感，但是面试结束之后语气缓和下来发现其实挺和蔼，还指出了我的不足，哪里需要加强：（leetcode刷题 + Linux） 上来先自我介绍，然后就是问能不能保证实习6个月，每周保证几天，老师知不知道。巴拉巴拉，很强势，略吓人！！ 先问了Linux，问掌握到什么程度，问了一个文件排序的问题，不会。。。。 还是问RBM与DBN的问题，跟上午差不多，说了能量函数和概率公式 问了RNN和LSTM，RNN讲的还可以，LSTM讲的太浅，好像不太受认可，过程中问了梯度迷散和梯度爆炸问题，梯度爆炸不会 项目上大同小异，怎么做的，流程是怎样，特征有哪些，用的什么模型 机器学习方面 首先问的是混淆矩阵，答曰不懂。然后进一步问如何判断结果的好坏，（ROC， AUC）这些，不懂，说应该要掌握一下这些。 然后让讲一下GBDT，说了一下原理，不满意，继续问深的，每一个树用的什么树（C30,C45还是CART），我说不太懂，基本都是找到代码来用，没有深入理解理论 问hadoop了解不，答曰不了解，实验室没条件。 算法题：给定一个数组A和A的长度n。求a, b 满足0&lt;=a&lt;b&lt;=n,使得A[b] - A[a]的差最大。 其实就是广点通面试的第一题，当时回来没看，还是不会做。(本质上是动态鬼哭啊) 经过提示，把它的最小值和差存下来，用O(n)的方法可以做到。写完之后给面试官看，没有考虑边界条件，尴尬。 12345678910111213def max_difference(nums): if len(nums) == 0: return False min_value = nums[0] d = 0 for i in range(1, len(nums)): if nums[i] &lt; min_value: min_value = nums[i] elif nums[i] - min_value &gt; d: d = nums[i] - min_value return d ###总结能想起来的基本这些，表现不太好。后来他送我出来，很nice的给我讲了我的问题：语言会python会java可以，C++不会也没关系，够了。最好能有一点项目。DBN这一块掌握的可以了，LSTM掌握的不行，有点差。然后hadoop实验室没条件就算了，现在很容易接触到，是个公司就在用。主要两点，首先leetcode刷题，第二，把linux搞搞，这两点可以自己做。","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"腾讯广点通数据挖掘岗实习生面试复盘","date":"2017-03-08T00:54:39.000Z","path":"2017/03/08/腾讯广点通数据挖掘岗实习生面试复盘/","text":"时间：2016.12.15，面试时间约一个半小时（两面） 地点：中关村银科大厦 岗位：广点通的数据挖掘实习岗 简历：V2版简历 感觉：还可以，给自己打3分吧(5分制) 过程复盘今天也算是确定找工作方向之后的初次面试，收到通知后还是很认真准备了的，而且第一次面腾讯，内心未免有一些小激动。整体感觉还好吧，我感觉面的还算可以，比暑假傻了吧唧面百度贴吧时好多了，可能还是达不到面试官的要求吧，在二面面完挂掉。 一面： 面试官是个美女，比较温柔，上来先自我介绍，聊项目，聊自己在项目中都做了什么工作，印象最深刻的和最难的部分，给她详细讲了华为项目中的RBM算法，后来又跟她聊了两个比赛，比赛说了个大概，没有深入展开。然后说做道题，出了一道算法题： 给出一个列表是一天的股票成交价格，如[1, 7, 4, 10, 9, 4, 2]，求如果买卖股票能获得最大收入。一天只能买一次，卖一次，且必须先买入再卖出。 其实根本上是一个求列表元素最大差的问题，只不过元素受限，一定是列表后面元素减前面元素的差。 当时的解法： O(n2)时间复杂度，很容易想，两个for循环，i 从头一个元素开始，j 从 i 开始，求lst[j] - lst[i]的最大值. 时间复杂度太高，被否定 O(nlogn)时间复杂度，想法是递归，先分成前后两个列表left, right，求max(right) - min(left)，把这个值记下来，然后再分别对left, right进行分割求差，递归调用直到两个都是一个元素即可遍历 python代码没写出来，递归掌握不好 第二种方法当时给了20分钟，最后没写出代码，但把思想讲明白了，接下来就是二面 二面： 两次面试间隔大约5分钟吧，去了一趟洗手间，二面开始，是个做技术的小哥，穿着白袜子大拖鞋就过来面试了，印象深刻！ 上来直入主题，看了简历，直接开始问比赛，问这个天池大赛是个什么情况，具体介绍了一下，然后问你们用的特征都是什么，我说一天的几个小时，一周的几天。然后问哪个特征的相关性最高，答曰一天内的时间相关性最高。然后问最后一共用了多少特征，我说就这两个，他一脸黑线。。。然后简单说了说上海联通数据大赛的情况，收获多少。他还详细问了这两个比赛投入了多少时间，答曰天池大概4到5天，然后上海联通因为自己做的投入10到15天左右吧。 然后开始做题： 第一题是链表翻转，不限语言，于是用python写的，写完之后这哥们很傻比的揪住我的prev指针先置空后就不应该有next属性，非得让我改，我的方法明明leetcode都通过了的！！！！ 第二题是写一个函数，传入一个数n,然后打印从1到n这些数的全排列，共有n!种排列。我的思想还是递归，分成两个列表lst1,lst2，lst1前n-1个元素，lst2最后1个元素，然后打印他们两个的全排列，两种方法，再递归调用lst1的，如此递归到lst1为两个元素即可。 函数实现上出了点问题，还是递归掌握有问题，函数打印上出了问题，我的递归调用比如调用到lst1时，打印lst1分裂后的排列方式，却忘记了lst2，最后改了半天也没改出来，就继续了，可能这块问题比较大把，思想有了，代码的实现上还是差一点 然后继续问进程和线程的区别是什么。答曰不知道，然后说因为是学通信的，因此计算机基础这块确实比较薄弱，这里应该也是挂掉的主要原因之一！ 然后我引导他问一些机器学习的问题，他问我哪一块掌握的最好，我说LR吧，然后他说你讲讲LR吧，我开始讲，过程中他不断提问题，后来问到为什么用sigmoid函数而不用别的函数（分类问题上），我的答案不符合他的预期，他也没了耐心，就结束了面试 结束我问最后这个lr的问题答案是什么，他还不说。后来我问面的如何，他委婉的说不太适合，我问我哪一块还需要再提高，他说计算机基础上这些还是要学一学，知道一下的。 这次面试结束，整体情况如上。 补充：一面时，那个女生还说了真正公司要做的可能比较杂，不想你们做竞赛可以专注于算法的提高，可能实习生需要做很多的杂活，不知道你能不能接受","tags":[{"name":"面试复盘","slug":"面试复盘","permalink":"http://yoursite.com/tags/面试复盘/"}]},{"title":"面试非算法知识点","date":"2017-03-08T00:49:29.000Z","path":"2017/03/08/面试非算法知识点/","text":"面试知识点 Programming language java8特性：java garbage collection要记住的三点： 对象有可能不被垃圾回收 垃圾回收并不等于“析构” 垃圾回收只与内存有关 finalize()方法 system.gc():强制垃圾回收，但也只是向系统提一个申请，并不确定可以垃圾回收 static 和 final:final可以理解为最终的，如果你不想一个变量在后期被改变那么就用final修饰，比如你的实际身高是不变的。 static的一个好处就是可以通过类名直接访问变量，大部分用在需要在多个方法中共享的时候。 static修饰的属性强调它们只有一个，final修饰的属性表明是一个常数（创建后不能被修改）。static final修饰的属性表示一旦给值，就不可修改，并且可以通过类名访问。 对于基本类型数据，用final会使数值恒定不变（创建后不能被修改）；但是对于引用，final会使引用恒定不变（进行声明时，必须将句柄初始化到一个具体的对象。而且不能再将句柄指向另一个对象）。但是，对象的本身是可以修改的。 static final域占据一段不能改变的存储空间。 static可以修饰：属性，方法，代码段，内部类（静态内部类或嵌套内部类） static修饰的属性的初始化在编译期（类加载的时候），初始化后能改变。 static修饰的属性所有对象都只有一个值。 static修饰的属性强调它们只有一个。 static修饰的属性、方法、代码段跟该类的具体对象无关，不创建对象也能调用static修饰的属性、方法等 static和“this、super”势不两立，static跟具体对象无关，而this、super正好跟具体对象有关。 static不可以修饰局部变量。 什么是referencejava中一切都被视为对象，但是操纵的时候并不是操纵对象本身，而是操纵对象的一个标识符，这个标识符就是引用(reference).可以有引用，但是并不一定有对象与它关联引用类似于c++的指针12String s = new String(&quot;abcd&quot;);//s就是新创建的这个对象的一个引用 nums==null 和 nums.length==0 有什么区别长度为0的数组int[] arr = new int[0]，也称为空数组，虽然arr长度为0，但是依然是一个对象 null数组，int[] arr = null；arr是一个数组类型的空引用。 访问权限 如果没有任何修饰词，为包访问权限(有时也称为friendly)，它可以被当前包中的所有其他类访问，但是对这个包之外的所有类，均为 private public, 所有人都能访问 private, 除了包含该成员的类之外，其他任何类都不能访问 protected, 跟继承有关，派生类可以访问。也有包访问权限，相同包内的其他类可以访问protected元素 Operating System 进程与线程的区别进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。 开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。 所以一个进程管着多个线程。 什么是锁mutex什么是信号量信号量(Semaphore)– 相当一个信号灯，程序里是一个非负整数，表示状态.在多线程里可以用来保护两个或多个关键代码段，这些关键代码段不能并发调用。 什么是栈溢出 栈溢出是由于C语言系列没有内置检查机制来确保复制到缓冲区的数据不得大于缓冲区的大小，因此当这个数据足够大的时候，将会溢出缓冲区的范围。 在Python中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 不同存储结构的速度量级（磁盘、SSD、内存、L1 cache）什么是IOinput/output 输入输出地址 Object Oriented Design 什么是继承继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 什么是单例Singletonjava模式之单例模式：单例模式确保一个类只有一个实例，自行提供这个实例并向整个系统提供这个实例。 特点： 一个类只能有一个实例 自己创建这个实例 整个系统都要使用这个实例 什么是工厂模式 Factory Network 什么是Socket我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。 socket就是网络连接的端点。就像一根网线，一头连到路由器，一头连到电脑。这两端就是socket。 socket编程就是利用一些函数开发网络应用。这些函数都与socket接口有关。 socket接口可以在各种系统上使用，比如linux，windows，mac。 从开发的角度看，socket类似文件。 这与开发文件读写程序时你打开的文件类似，只不过这是一个socket文件。 socket的结构socket的结构很简单，只有三个元素，协议，端口号，IP地址。 TCP/IP三次握手参考博客 首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 终端连接的四次挥手： 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 什么是HTTPHTTP（Hypertext Transfer Protocol），即超文本传输协议。是WWW浏览器和WWW服务器之间的应用层通讯协议。HTTP协议是基于TCP/IP之上的协议，它不仅保证正确传输超文本文档，还确定传输文档中的哪一部分，以及哪一部分内容首先显示（如文本先与图形）等等。 什么是APIAPI（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 TCP 和 UDP有什么区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 TCP UDP 是否连接 面向连接 面向非连接 传输可靠性 可靠 不可靠 应用场合 传输大量数据 少量数据 速度 慢 快 Databasemysql foreigh key： 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。 FOREIGN KEY 约束用于预防破坏表之间连接的动作。 FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 inner join, outer join: inner join 查询的是只有两表的字段的值完全相等的 left outer join 是以左边表为基准，即使右表没有匹配，也从左表返回所有的行 right outer join 以右边表为基准 多对多关系怎么设计在多对多关系中，A 表中的一行可以匹配 B 表中的多行，反之亦然。要创建这种关系，需要定义第三个表，称为结合表，它的主键由 A 表和 B 表的外部键组成。例如，authors 和 titles 表具有多对多关系，这是由于这些表都与titleauthors 表具有一对多关系。titleauthors 表的主键是 au_id 列（authors 表的主键）和 title_id 列（titles 表的主键）的组合。 SQL 与 NoSQL的区别关系型数据库中的表都是存储一些格式化的数据结构，每个元组字段的组成都一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段，这样的结构可以便于表与表之间进行连接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。而非关系型数据库以键值对存储，它的结构不固定，每一个元组可以有不一样的字段，搜索每个元组可以根据需要增加一些自己的键值对，这样就不会局限于固定的结构，可以减少一些时间和空间的开销。 NoSQL特点： 它们可以处理超大量的数据。 它们运行在便宜的PC服务器集群上。 它们击碎了性能瓶颈。 没有过多的操作。 什么是Transaction事务提供了一种机制，可用来将一系列数据库更改归入一个逻辑操作。更改数据库后，所做的更改可以作为一个单元进行提交或取消。事务可确保遵循原子性、一致性、隔离性和持续性（ACID）这几种属性，以使数据能够正确地提交到数据库中。 只要事务中一个操作行为失败，整个事务就会失败。 什么是ACID一个事务本质上有四个特点ACID： Atomicity原子性 Consistency一致性 Isolation隔离性 Durability耐久性","tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"时间都去哪儿了","date":"2017-01-01T10:33:44.000Z","path":"2017/01/01/时间都去哪儿了/","text":"时间都去哪儿了？？ 说实话，总感觉2016就在眼前，2015就像昨天，一切都是从前的样子，时间表就猝不及防的跳到了2017。有点失落，有点迷茫也会有点期待。只是不知不觉自己就来到了24岁这个年纪，真的不太好适应。 因为在自己深度的潜意识里，还是个屁大的孩子，还没有上完学，收入还得靠父母，一切感觉都存留在高中时的惯性上面，却不知不觉自己已经到了第二个本命年。 还记的以前玩FM的时候，我最喜欢挖掘年轻的小牛来培养，享受把十七八岁的小牛培养成世界级球星的成就感。那个时候自己用上帝视角看着一群又一群的球员，想的最多的估计就是：这人24了，老了。。。身体练不出来了，技术也够呛了。看到20岁及以下的小将就会兴奋，觉得，嗯，这球员大有可为，练练试试。。。然而当自己也猛的来到24岁的年纪，懵懵的发现，24就老了吗，并没有把，好像很多事情才刚刚开始，很多事情还没有开始，好像另一段全新的人生才正准备起步，好像依然大有可为啊。 然而好多时候又真真切切的感受到老了。得益于我的两个哥哥，我从挺小就开始看NBA和足球了。所以我记得最牢印象最深的那批球星，确确实实都老的老，退役的退役了。亨利，舍甫琴科，劳尔，贝克汉姆，齐达内，皮尔洛，加图索，皮耶罗，特雷泽盖，维埃拉，哈维，伊涅斯塔，大罗小罗，这些曾经那么辉煌的名字，现在都归于沉寂。C罗，梅西，小法，范佩西，罗本，里贝里，比利亚，托雷斯，卡卡，伊布，这些当年被称作小牛亦或是金童的人，现在都到了职业生涯的末年。2016对于C罗是完美的一年，欧冠欧洲杯金球奖加冕，彰显了他的伟大。然而当主持人念出，31岁的C罗的时候，我茫然失措，原来当年那个灵动的小小罗，也31了。时间都去哪儿了？还记得在看16年勇士对骑士的总决赛的时候，解说员介绍到， 其实勇士当年也是一支传奇的球队，估计大部分新球迷都不知道，大概8年前的时候，那时候勇士还是巴郎戴维斯和杰克船长的时代，创造了黑八奇迹，在季后赛第一轮把当时的全联盟第一名小牛队淘汰出局 那一刻，恍若隔世。因为我看过，转眼间，8年了。转眼间，这也成了解说员口中的“当年”。我熟悉的解说员口中的“当年”，是满眼崇拜的听他们讲70年代的大鸟伯德，80年代的魔术师约翰逊，90年代的飞人乔丹，那是我未曾见证过的传说，永远带着强烈的神秘色彩。可当这个“当年”来到21世纪，当“当年”也变成了我的当年，可以清清楚楚回忆起的当年，居然让我这么百感交集。我们当年追的大姚，科比，麦迪，卡特，艾佛森，邓肯，加内特，雷阿伦，奥尼尔，你们都去哪儿了？现在看着整个联盟一张张稚嫩的新面孔，找了好久都找不到一个我认得的球员，只好承认，时间，真的改变了些什么吧。 有多少次觉得自己就是个小屁孩，20多岁的年纪离自己好远好远。还记得以前看《奋斗》的时候，觉得他们都是25岁的年纪，好大，离我好远。有多少次觉得自己还是个屁颠屁颠的学生，觉得工作了的人都好大。然而当认识了很多很多新的朋友比自己小好多都已工作多年的时候才意识到，自己也来到了所谓的青年时代，也被人们承认为独立的个体而不是受监护人看管的小孩了。自己也该学着规划自己的人生，决定自己的方向，追求自己的所求了，再也不是无忧无虑啥都不想的小孩了。 想回去孩童时代吗？ 想。 不想。 不知道想不想。。。 只想潜心继续往前走。因为不管想不想，时间都不等人。突然发觉自己并没有老，因为自己从来不曾沉浸在过去。这个世界太过精彩，太多的东西能引起我的兴趣，太多的领域值得我去探索，太多的人值得我去爱。突然发觉时间虽快，貌似自己也着实改变了很多，成长了很多，收获了很多。 突然觉得，一切，好像都还不错。 加油，2017！ 2017.1.1","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"早安，2017","date":"2016-12-31T23:12:42.000Z","path":"2017/01/01/早安，2017/","text":"早安，2017！ 2017年的第一个清晨，人生的第一篇博文。 不知道自己能写多久的博客，就像不知道这一年会怎样度过，但知道自己在努力就足够。就像回首2016，收获大于遗憾，开心大于后悔，知道自己在进步就满足。 不想作多么煽情的总结，更不想定多么宏伟的目标。只想淡淡的，缓缓的去前进。 但愿当我回首起这些往事的时候，能说的是： 很惭愧，只做了一点微小的工作，谢谢大家！ 足矣。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]